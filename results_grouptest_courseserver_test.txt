============================= test session starts ==============================
platform linux -- Python 3.7.3, pytest-6.2.3, py-1.10.0, pluggy-0.13.1
rootdir: /tmp_amd/kamen/export/kamen/3/cs1531/automark/tempstore, configfile: pytest.ini
plugins: forked-1.3.0, xdist-2.2.1, hypothesis-6.1.1, timeout-1.4.2
collected 316 items

http_tests/admin_http_test.py ......F                                    [  2%]
http_tests/auth_http_test.py ..........F                                 [  5%]
http_tests/channel_http_test.py ...FFFFFFFFFFFFFF..FFF...FF....FF..FFFFF [ 18%]
                                                                         [ 18%]
http_tests/channels_http_test.py FFFFFFFFFFF.F                           [ 22%]
http_tests/dm_http_test.py FFFF.F..F....FF..FFFFFFF                      [ 30%]
http_tests/echo_http_test.py F                                           [ 30%]
http_tests/message_http_test.py F.F.FF...FF..FF.FF..F                    [ 37%]
http_tests/other_http_test.py FF..FFFF                                   [ 39%]
http_tests/user_http_test.py FF.........F.                               [ 43%]
tests/admin_test.py ......                                               [ 45%]
tests/auth_test.py .................                                     [ 50%]
tests/channel_test.py ................................................   [ 66%]
tests/channels_test.py ...............                                   [ 70%]
tests/dm_test.py ..............................                          [ 80%]
tests/echo_test.py ..                                                    [ 81%]
tests/message_test.py ...................................                [ 92%]
tests/other_test.py ........                                             [ 94%]
tests/user_test.py .................                                     [100%]

=================================== FAILURES ===================================
___________ test_invalid_permissin_id_admin_userpermission_change_v1 ___________

clear_data = None

    def test_invalid_permissin_id_admin_userpermission_change_v1(clear_data):
        '''
        Test if admin_userpermission_change function permissin_id is invalid
        '''
        user1 = requests.post(f'{url}/auth/register/v2', json = {
            'email': 'ska@gmail.com',
            'password': '1234aaaaaa',
            'name_first': 'Tom',
            'name_last': 'diaaa',
        })
        user2 = requests.post(f'{url}/auth/register/v2', json = {
            'email': 'skad@gmail.com',
            'password': '1234aasaaaa',
            'name_first': 'Brown',
            'name_last': 'diaam',
        })
        payload1 = user1.json()
        payload2 = user2.json()
>       assert requests.post(f'{url}/admin/userpermission/change/v1', json = {
            'token' : payload1['token'],
            'u_id' : payload2['auth_user_id'],
            'permission_id' : 999,
        }).status_code == AccessError.code
E       AssertionError: assert 400 == 403
E        +  where 400 = <Response [400]>.status_code
E        +    where <Response [400]> = <function post at 0x7fbf3aa42048>('http://localhost:60811//admin/userpermission/change/v1', json={'permission_id': 999, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjEyLCJsb2dpbl90aW1lIjoxNjE4MjU1MDIwLCJzYWx0IjoiMjhlYTgyZTQtYTE2My00NTZiLWFjYTUtNGM0N2VjZDhkYjE4In0.PhIlrdwmVupVGSlqgRa97z8nsyfClVyaK-6k6IkVGTM', 'u_id': 13})
E        +      where <function post at 0x7fbf3aa42048> = requests.post
E        +  and   403 = AccessError.code

http_tests/admin_http_test.py:190: AssertionError
__________________________ test_invalid_token_logout ___________________________

clear_data = None

    def test_invalid_token_logout(clear_data):
        requests.post(config.url + 'auth/register/v2', json={
            'email': 'tom@gmail.com',
            'password': 'hello1234',
            'name_first': 'tom',
            'name_last': 'brown',
        })
        requests.post(config.url + 'auth/login/v2', json={
            'email': 'tom@gmail.com',
            'password': 'hello1234',
        })
>       assert requests.post(config.url + 'auth/logout/v1', json = {
            'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZXNzaW9uX2lkIjo1fQ.L6p3XfadFmkykAtJmcBFkXAvAaxa52Tz3lvitd9ZNNo'
        }).status_code == AccessError.code
E       AssertionError: assert 200 == 403
E        +  where 200 = <Response [200]>.status_code
E        +    where <Response [200]> = <function post at 0x7fbf3aa42048>(('http://localhost:60811/' + 'auth/logout/v1'), json={'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZXNzaW9uX2lkIjo1fQ.L6p3XfadFmkykAtJmcBFkXAvAaxa52Tz3lvitd9ZNNo'})
E        +      where <function post at 0x7fbf3aa42048> = requests.post
E        +      and   'http://localhost:60811/' = config.url
E        +  and   403 = AccessError.code

http_tests/auth_http_test.py:159: AssertionError
_______________________ test_channel_invite_v1_AccessErr _______________________

clear = None

    def test_channel_invite_v1_AccessErr(clear):
        """
        AccessError happens when auth is not in channel for invite
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
>       assert requests.post(f"{url}/channel/invite/v2", json={
            'token': reg_info2['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info1['auth_user_id']
        }).status_code == 403
E       AssertionError: assert 400 == 403
E        +  where 400 = <Response [400]>.status_code
E        +    where <Response [400]> = <function post at 0x7fbf3aa42048>('http://localhost:60811//channel/invite/v2', json={'channel_id': 32, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjMxLCJsb2dpbl90aW1lIjoxNjE4MjU1MDIxLCJzYWx0IjoiOTMwNjRkZTEtNjg5Mi00MWQ3LWI2ZGQtZGU4ZTY3MzEwMDg0In0.IFiVf3Q6ttwtNmJFN_7GBowiVbnuxa5XGOwNaRN-RYg', 'u_id': 30})
E        +      where <function post at 0x7fbf3aa42048> = requests.post

http_tests/channel_http_test.py:207: AssertionError
_______________________ test_channel_invite_v1_AddMulti ________________________

clear = None

    def test_channel_invite_v1_AddMulti(clear):
        """
        Tests that multiple users can be added to channel for invite
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
        requests.post(f"{url}/channel/invite/v2", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info2['auth_user_id']
        })
        requests.post(f"{url}/channel/invite/v2", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info3['auth_user_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id']
        })
>       channel_details1 = channel_details1.json()

http_tests/channel_http_test.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________ test_channel_invite_invalid_token _______________________

clear = None

    def test_channel_invite_invalid_token(clear):
        """
        Test invalid token for invite
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
>       assert requests.post(f"{url}/channel/invite/v2", json={
            'token': 'invalid_token',
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info1['auth_user_id']
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7fbf3aa42048>('http://localhost:60811//channel/invite/v2', json={'channel_id': 38, 'token': 'invalid_token', 'u_id': 37})
E        +      where <function post at 0x7fbf3aa42048> = requests.post

http_tests/channel_http_test.py:279: AssertionError
_______________________ test_channel_details_v1_InputErr _______________________

clear = None

    def test_channel_details_v1_InputErr(clear):
        """
        InputError happens when channel_id is invalid
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
>       assert requests.get(f"{url}/channel/details/v2", json={
            'token': reg_info1['token'],
            'channel_id': INVALID_ID
        }).status_code == 400
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//channel/details/v2', json={'channel_id': 9999, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM5LCJsb2dpbl90aW1lIjoxNjE4MjU1MDIxLCJzYWx0IjoiYjFhZGM5YjQtNzEyMC00N2YyLWFiZjgtODQ4ZDZmMjg3NzlkIn0.pQJTDEGuUF4uKz6PN1A3X_ev0H7vPd6UCqieY9OMW2c'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/channel_http_test.py:300: AssertionError
______________________ test_channel_details_v1_AccessErr _______________________

clear = None

    def test_channel_details_v1_AccessErr(clear):
        """
        AccessError happens when auth is not in channel
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
>       assert requests.get(f"{url}/channel/details/v2", json={
            'token': reg_info2['token'],
            'channel_id': channel_id1['channel_id']
        }).status_code == 403
E       AssertionError: assert 500 == 403
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//channel/details/v2', json={'channel_id': 42, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQxLCJsb2dpbl90aW1lIjoxNjE4MjU1MDIxLCJzYWx0IjoiMmJiNTgyYjEtOWVhNC00NTEyLTlmMmUtYTA0MjliM2E4ZjcyIn0.Re8SHylAs8D1VfrEyZJ70OiqhgO5Ieq9XgBVZq2M1j8'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/channel_http_test.py:329: AssertionError
________________________ test_channel_details_v1_OneInv ________________________

clear = None

    def test_channel_details_v1_OneInv(clear):
        """
        Tests that correct details are provided when calling function for details
        After inviting one user
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
        requests.post(f"{url}/channel/invite/v2", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info2['auth_user_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id']
        })
>       channel_details1 = channel_details1.json()

http_tests/channel_http_test.py:368: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________ test_channel_details_invalid_token ______________________

clear = None

    def test_channel_details_invalid_token(clear):
        """
        Test invalid token for details
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
>       assert requests.get(f"{url}/channel/details/v2", json={
            'token': 'invalid_token',
            'channel_id': channel_id1['channel_id']
        }).status_code == 400
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//channel/details/v2', json={'channel_id': 47, 'token': 'invalid_token'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/channel_http_test.py:391: AssertionError
____________________ test_channel_messages_v1_input_error1 _____________________

clear = None
user_token1 = {'auth_user_id': 48, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQ4LCJsb2dpbl90aW1lIjoxNjE4MjU1MDIxLCJzYWx0IjoiMGQ4MzQyZjUtODIzOS00OGMyLTk5MWYtZTgxMjA1MDcyZDg4In0.QGrhybKzqZQNm4P798_MXt6OfISCmxUKTmyYw2IZcQM'}
public_channel = {'channel_id': 49}

    def test_channel_messages_v1_input_error1(clear, user_token1, public_channel):
        """
        InputError to be thrown when channel_id is invalid
        """
        start = 0
>       assert requests.get(f"{url}/channel/messages/v2", json={
            'token': user_token1['token'],
            'channel_id': INVALID_ID,
            'start': start
        }).status_code == INPUT_ERROR
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//channel/messages/v2', json={'channel_id': 9999, 'start': 0, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQ4LCJsb2dpbl90aW1lIjoxNjE4MjU1MDIxLCJzYWx0IjoiMGQ4MzQyZjUtODIzOS00OGMyLTk5MWYtZTgxMjA1MDcyZDg4In0.QGrhybKzqZQNm4P798_MXt6OfISCmxUKTmyYw2IZcQM'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/channel_http_test.py:405: AssertionError
____________________ test_channel_messages_v1_input_error2 _____________________

clear = None
user_token1 = {'auth_user_id': 50, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjUwLCJsb2dpbl90aW1lIjoxNjE4MjU1MDIxLCJzYWx0IjoiMGVmMjI1MDctN2M1MC00MWM4LTk4MzItNjdkMmFhZTFiNDE4In0.SrulVPikIg6Jzxkw_vaON9it0u_kxQgnOkvYKwujf24'}
public_channel = {'channel_id': 51}

    def test_channel_messages_v1_input_error2(clear, user_token1, public_channel):
        """
        InputError2 to be thrown when start is greater than number of messages in channel
        """
        channel_id = public_channel['channel_id']
        requests.post(f"{url}/message/send/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id,
            'message': "Hello"
        }).json()
        start = 1
>       assert requests.get(f"{url}/channel/messages/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id,
            'start': start
        }).status_code == INPUT_ERROR
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//channel/messages/v2', json={'channel_id': 51, 'start': 1, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjUwLCJsb2dpbl90aW1lIjoxNjE4MjU1MDIxLCJzYWx0IjoiMGVmMjI1MDctN2M1MC00MWM4LTk4MzItNjdkMmFhZTFiNDE4In0.SrulVPikIg6Jzxkw_vaON9it0u_kxQgnOkvYKwujf24'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/channel_http_test.py:422: AssertionError
____________________ test_channel_messages_v1_access_error _____________________

clear = None
user_token1 = {'auth_user_id': 53, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjUzLCJsb2dpbl90aW1lIjoxNjE4MjU1MDIxLCJzYWx0IjoiMmM0ODM2NWEtNWQzOC00YjhhLWE5YjgtMmRhNGI3YmEzZTE5In0.2kw9ynARoT13XXl4jusFtWaIW2HHcsy850n-QMBTOXQ'}
user_token2 = {'auth_user_id': 54, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjU0LCJsb2dpbl90aW1lIjoxNjE4MjU1MDIxLCJzYWx0IjoiMGQ3NTQ4NWItYjMyMC00NzRmLTliYzQtNTdkOThiYzU3OWExIn0.v03GDPg2JRPaC-NEgQWSlN98VHmo8WB6rMFGtr9Eki4'}
public_channel = {'channel_id': 55}

    def test_channel_messages_v1_access_error(clear, user_token1, user_token2, public_channel):
        """
        Accessing auth_user2's messages should throw an Access Error since only
        user_token1 is in the channel (added during public_channel function)
        """
        channel_id = public_channel['channel_id']
        requests.post(f"{url}/message/send/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id,
            'message': "Hello"
        }).json()
        start = 0
>       assert requests.get(f"{url}/channel/messages/v2", json={
            'token': user_token2['token'],
            'channel_id': channel_id,
            'start': start
        }).status_code == ACCESS_ERROR
E       AssertionError: assert 500 == 403
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//channel/messages/v2', json={'channel_id': 55, 'start': 0, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjU0LCJsb2dpbl90aW1lIjoxNjE4MjU1MDIxLCJzYWx0IjoiMGQ3NTQ4NWItYjMyMC00NzRmLTliYzQtNTdkOThiYzU3OWExIn0.v03GDPg2JRPaC-NEgQWSlN98VHmo8WB6rMFGtr9Eki4'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/channel_http_test.py:440: AssertionError
_______________________ test_channel_messages_v1_simple ________________________

clear = None
user_token1 = {'auth_user_id': 57, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjU3LCJsb2dpbl90aW1lIjoxNjE4MjU1MDIxLCJzYWx0IjoiYTk5YjMwNmYtZjg1MC00OTI4LWE3NTAtZTA5ZTFkOGUzNzVhIn0.-J94zJJlipjwpxHmCjZN6ThEehobmdgvKYukZwlsjug'}
user_token2 = {'auth_user_id': 58, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjU4LCJsb2dpbl90aW1lIjoxNjE4MjU1MDIxLCJzYWx0IjoiYTJhMWU4M2ItYzQ4MC00YzI5LTk3NWYtODZkYzE0OGQ5OTEyIn0.hLs1KU6WRC2CR3HXaa-1eteZRaDkiqaCquxBQ3Xp5-U'}
public_channel = {'channel_id': 59}

    def test_channel_messages_v1_simple(clear, user_token1, user_token2, public_channel):
        channel_id = public_channel['channel_id']
        requests.post(f"{url}/message/send/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id,
            'message': "Hello"
        }).json()
        start = 0
        messages = requests.get(f"{url}/channel/messages/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id,
>           'start': start
        }).json()

http_tests/channel_http_test.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
________________________ test_channel_messages_v1_many _________________________

clear = None
user_token1 = {'auth_user_id': 61, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjYxLCJsb2dpbl90aW1lIjoxNjE4MjU1MDIxLCJzYWx0IjoiMzUwNTBjYTgtNzE1Ny00NzhiLThhZmEtOGY1Y2FlODRkMDI2In0.nG-hXjFqPZsBGu04_r9jbOOE48ycdCearBnRMhdY018'}
user_token2 = {'auth_user_id': 62, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjYyLCJsb2dpbl90aW1lIjoxNjE4MjU1MDIxLCJzYWx0IjoiZTZhYjMxMzktNDhmMC00YzMwLWIxYzYtNzViZTNiNTVlODM2In0.hBuAaSybC2EIXmkb-sf-PZmPlSXysGuokOQo0ENK7jo'}
public_channel = {'channel_id': 63}

    def test_channel_messages_v1_many(clear, user_token1, user_token2, public_channel):
        channel_id = public_channel['channel_id']
        for i in range(0, 50):
            requests.post(f"{url}/message/send/v2", json={
                'token': user_token1['token'],
                'channel_id': channel_id,
                'message': f"message number {i}"
            }).json()
        start = 0
        messages = requests.get(f"{url}/channel/messages/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id,
>           'start': start
        }).json()

http_tests/channel_http_test.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_____________________ test_channel_messages_invalid_token ______________________

clear = None, channel_id1 = {'channel_id': 115}

    def test_channel_messages_invalid_token(clear, channel_id1):
>       assert requests.get(f"{url}/channel/messages/v2", json={
            'token': INVALID_TOKEN,
            'channel_id': channel_id1['channel_id'],
            'start': 0
        }).status_code == INPUT_ERROR
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//channel/messages/v2', json={'channel_id': 115, 'start': 0, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzZXNzaW9uX2lkIjo5OTk5fQ.DLVgZojClKM67VJkwqWJ9iyYG-qbWH1MHbGe0noFt-s'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/channel_http_test.py:478: AssertionError
______________________ test_channel_join_v1_empty_channel ______________________

clear = None
user_token1 = {'auth_user_id': 116, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjExNiwibG9naW5fdGltZSI6MTYxODI1NTAyMiwic2FsdCI6ImRhZWZlMDIyLWEzMTUtNDYyNS05Y2MxLWRhM2UxMjcyZmU5NCJ9.KVpIVrvhNAN7LSYzyTguh1YxXZipJdGHMzVWEiFZ6Y4'}
public_channel = {'channel_id': 117}

    def test_channel_join_v1_empty_channel(clear, user_token1, public_channel):
        """
        Test adding to empty channel
        """
        channel_id = public_channel['channel_id']
        requests.post(f"{url}/channel/join/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id
        })
        channel_dict = requests.get(f"{url}/channel/details/v2", json={
            'token': user_token1['token'],
>           'channel_id': channel_id
        }).json()

http_tests/channel_http_test.py:499: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________ test_channel_join_v1_check_details ______________________

clear = None
user_token1 = {'auth_user_id': 124, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjEyNCwibG9naW5fdGltZSI6MTYxODI1NTAyMiwic2FsdCI6ImEyZjg0OGRlLThkMWItNDkzMC05Y2NlLTJhYWI4ZmYzYTg2NSJ9.eJY2ZK-D-2cFmrVeePNkEYFPc5dewsjnvL-J0Whthfo'}
user_token2 = {'auth_user_id': 125, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjEyNSwibG9naW5fdGltZSI6MTYxODI1NTAyMiwic2FsdCI6IjY3NzI1ZGE3LTY4ZDgtNDMwZi1hNGU4LTAzNDc1MzRiMjQ2ZiJ9.GXvGaTU1WFkTdJIxD8-H--vTimsXW9vWsZp4DYWaMbI'}
public_channel = {'channel_id': 126}

    def test_channel_join_v1_check_details(clear, user_token1, user_token2, public_channel):
        """
        Test if details are correctly added when adding more than one user
        """
        channel_id = public_channel['channel_id']
        requests.post(f"{url}/channel/join/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id
        })
        requests.post(f"{url}/channel/join/v2", json={
            'token': user_token2['token'],
            'channel_id': channel_id
        })
        channel_info = requests.get(f"{url}/channel/details/v2", json={
            'token': user_token1['token'],
>           'channel_id': channel_id
        }).json()

http_tests/channel_http_test.py:542: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_channel_join_invalid_token ________________________

clear = None, channel_id1 = {'channel_id': 128}

    def test_channel_join_invalid_token(clear, channel_id1):
>       assert requests.post(f"{url}/channel/join/v2", json={
            'token': INVALID_TOKEN,
            'channel_id': channel_id1['channel_id']
        }).status_code == INPUT_ERROR
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7fbf3aa42048>('http://localhost:60811//channel/join/v2', json={'channel_id': 128, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzZXNzaW9uX2lkIjo5OTk5fQ.DLVgZojClKM67VJkwqWJ9iyYG-qbWH1MHbGe0noFt-s'})
E        +      where <function post at 0x7fbf3aa42048> = requests.post

http_tests/channel_http_test.py:552: AssertionError
_________________________ test_channel_join_owner_perm _________________________

clear = None, channel_id1 = {'channel_id': 130}
user_token1 = {'auth_user_id': 129, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjEyOSwibG9naW5fdGltZSI6MTYxODI1NTAyMiwic2FsdCI6ImYzNTQwNjM0LWU2ODktNDY1MS05NTZlLWE5M2U3Nzk1ZDllNyJ9.vOiIbELntWaf9LCDV56Ko-PLaZV4HLDcqjOfpM7TuTk'}
user_token2 = {'auth_user_id': 131, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjEzMSwibG9naW5fdGltZSI6MTYxODI1NTAyMiwic2FsdCI6ImFjYjQwZGQ3LThiMmEtNGM4MS04MjFjLTliZjAzZjM2ODI0OSJ9.vD41TgxAT551kiM-F-oOhS5lvBlWzlyLeL9NFESD8cA'}

    def test_channel_join_owner_perm(clear, channel_id1, user_token1, user_token2):
        requests.post(f"{url}/channels/create/v2", json={
            'token': user_token2['token'],
            'name': "Channel",
            'is_public': False
        }).json()
        requests.post(f"{url}/channel/join/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id1['channel_id']
        })
        details = requests.get(f"{url}/channel/details/v2", json={
            'token': user_token1['token'],
>           'channel_id': channel_id1['channel_id']
        }).json()

http_tests/channel_http_test.py:569: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________ test_channel_addowner_v1_AddMulti _______________________

clear = None

    def test_channel_addowner_v1_AddMulti(clear):
        """
        Test whether multiple users will be added as owner of the channel properly
        in correct order
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
        requests.post(f"{url}/channel/addowner/v1", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info2['auth_user_id']
        })
        requests.post(f"{url}/channel/addowner/v1", json={
            'token': reg_info2['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info3['auth_user_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id']
        })
>       channel_details1 = channel_details1.json()

http_tests/channel_http_test.py:734: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_____________________ test_channel_addowner_invalid_token ______________________

clear = None

    def test_channel_addowner_invalid_token(clear):
        """
        Test invalid token for addowner
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
>       assert requests.post(f"{url}/channel/addowner/v1", json={
            'token': 'invalid_token',
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info1['auth_user_id']
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7fbf3aa42048>('http://localhost:60811//channel/addowner/v1', json={'channel_id': 147, 'token': 'invalid_token', 'u_id': 146})
E        +      where <function post at 0x7fbf3aa42048> = requests.post

http_tests/channel_http_test.py:755: AssertionError
___________________ test_channel_removeowner_v1_RemoveMulti ____________________

clear = None

    def test_channel_removeowner_v1_RemoveMulti(clear):
        """
        Test whether multiple users will be removed as owner of the channel properly
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
        requests.post(f"{url}/channel/addowner/v1", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info2['auth_user_id']
        })
        requests.post(f"{url}/channel/addowner/v1", json={
            'token': reg_info2['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info3['auth_user_id']
        })
        requests.post(f"{url}/channel/removeowner/v1", json={
            'token': reg_info3['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info2['auth_user_id']
        })
        requests.post(f"{url}/channel/removeowner/v1", json={
            'token': reg_info3['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info1['auth_user_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': reg_info3['token'],
            'channel_id': channel_id1['channel_id']
        })
>       channel_details1 = channel_details1.json()

http_tests/channel_http_test.py:960: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
____________________ test_channel_removeowner_invalid_token ____________________

clear = None

    def test_channel_removeowner_invalid_token(clear):
        """
        Test invalid token for removeowner
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
>       assert requests.post(f"{url}/channel/removeowner/v1", json={
            'token': 'invalid_token',
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info1['auth_user_id']
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7fbf3aa42048>('http://localhost:60811//channel/removeowner/v1', json={'channel_id': 165, 'token': 'invalid_token', 'u_id': 164})
E        +      where <function post at 0x7fbf3aa42048> = requests.post

http_tests/channel_http_test.py:981: AssertionError
_________________________ test_channel_leave_v1_Leave1 _________________________

clear = None
user_token1 = {'auth_user_id': 170, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE3MCwibG9naW5fdGltZSI6MTYxODI1NTAyMiwic2FsdCI6ImM2N2U5MDdhLTE5OGMtNDg2YS1hZDBkLWQyMjY0NTNiMTJmOSJ9.fdXXfigTW4un-uEdsRpoWGPwM0Aj2boqtObmk8s0IuI'}
channel_id1 = {'channel_id': 171}
user_token2 = {'auth_user_id': 172, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE3MiwibG9naW5fdGltZSI6MTYxODI1NTAyMiwic2FsdCI6IjYxOGQyNzFjLTZkMjctNGY3My1hMjk5LWNjNDg5ODE1ZDM2NyJ9.GLaSQqo6D4g6_VNG5YRQ7LsIgfzu2tUP32rpcjvu3Uw'}

    def test_channel_leave_v1_Leave1(clear, user_token1, channel_id1, user_token2):
        """
        Test whether a normal member can leave the channel properly
        """
        requests.post(f"{url}/channel/invite/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': user_token2['auth_user_id']
        })
        requests.post(f"{url}/channel/leave/v1", json={
            'token': user_token2['token'],
            'channel_id': channel_id1['channel_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': user_token1['token'],
>           'channel_id': channel_id1['channel_id']
        }).json()

http_tests/channel_http_test.py:1025: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_channel_leave_v1_LeaveMulti _______________________

clear = None
user_token1 = {'auth_user_id': 173, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE3MywibG9naW5fdGltZSI6MTYxODI1NTAyMiwic2FsdCI6IjU5MDczOTc1LTRiZjgtNGY0YS1hZjFhLTdlOTg0MDJkMzIzZCJ9.ArQAkpLaNnzxxtvzcf4TrNybbj-pb-W-KKEMpAWloU0'}
channel_id1 = {'channel_id': 174}
user_token2 = {'auth_user_id': 175, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE3NSwibG9naW5fdGltZSI6MTYxODI1NTAyMiwic2FsdCI6IjJiOGNmMjNhLTI2MjAtNDc0ZS04YWRkLTI1NjIyZTNmM2E5ZCJ9.JNK6AiULmyMxQqOI7wJp6N6VEkK-22swKp04y-N8Y7Q'}
user_token3 = {'auth_user_id': 176, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE3NiwibG9naW5fdGltZSI6MTYxODI1NTAyMiwic2FsdCI6IjgyOWJhZjMyLWRjOTktNDg0My1hNjg3LWU1ZWNmNzdjY2Y3NCJ9.UvmPd5ZA-mSvkoEASttp44tPBuV4MiZ7wk230VYWT6c'}

    def test_channel_leave_v1_LeaveMulti(clear, user_token1, channel_id1, user_token2, user_token3):
        """
        Test whether multiple members can leave the channel properly
        """
        requests.post(f"{url}/channel/invite/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': user_token2['auth_user_id']
        })
        requests.post(f"{url}/channel/invite/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': user_token3['auth_user_id']
        })
        requests.post(f"{url}/channel/leave/v1", json={
            'token': user_token2['token'],
            'channel_id': channel_id1['channel_id']
        })
        requests.post(f"{url}/channel/leave/v1", json={
            'token': user_token3['token'],
            'channel_id': channel_id1['channel_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': user_token1['token'],
>           'channel_id': channel_id1['channel_id']
        }).json()

http_tests/channel_http_test.py:1054: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_channel_leave_v1_LeaveOwner _______________________

clear = None, channel_id1 = {'channel_id': 178}
user_token1 = {'auth_user_id': 177, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE3NywibG9naW5fdGltZSI6MTYxODI1NTAyMiwic2FsdCI6ImNkMzYxMTBhLTg4NjAtNGEzNC1iN2Y5LTU5OWI1NTI4NTk3YiJ9.W3YVu4ePY7Bu7BWfb8h6rzNHSBLyTjQ1p0mh4NhXGp4'}
user_token2 = {'auth_user_id': 179, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE3OSwibG9naW5fdGltZSI6MTYxODI1NTAyMiwic2FsdCI6ImFjNTM0NmVkLTIwZWEtNGQ4NC1hMzg2LWU3OTIyOTU5MjkwYyJ9.dqPAd9i1WO-VGaHOx_TDhkG49UyNB_xAiqAU-jl5dWo'}

    def test_channel_leave_v1_LeaveOwner(clear, channel_id1, user_token1, user_token2):
        """
        Test whether a owner can leave the channel properly (not the last owner)
        They must be removed from all_members and owner_members
        """
        requests.post(f"{url}/channel/addowner/v1", json={
            'token': user_token1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': user_token2['auth_user_id']
        })
        requests.post(f"{url}/channel/leave/v1", json={
            'token': user_token2['token'],
            'channel_id': channel_id1['channel_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': user_token1['token'],
>           'channel_id': channel_id1['channel_id']
        }).json()

http_tests/channel_http_test.py:1075: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_channel_leave_v1_last_owner _______________________

clear = None
user_token1 = {'auth_user_id': 180, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE4MCwibG9naW5fdGltZSI6MTYxODI1NTAyMiwic2FsdCI6Ijk3MTZiMGZjLTAxM2MtNGJhZS1hYTdiLTI4NzBiYTVmZTUzOSJ9._uZ93WC83goIj3Uwee-cSLuh7VE_fbcdlifv40wkZPk'}
channel_id1 = {'channel_id': 181}

    def test_channel_leave_v1_last_owner(clear, user_token1, channel_id1):
        requests.post(f"{url}/channel/leave/v1", json={
            'token': user_token1['token'],
            'channel_id': channel_id1['channel_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': user_token1['token'],
>           'channel_id': channel_id1['channel_id']
        }).json()

http_tests/channel_http_test.py:1089: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_channel_leave_invalid_token _______________________

clear = None, channel_id1 = {'channel_id': 183}

    def test_channel_leave_invalid_token(clear, channel_id1):
>       assert requests.post(f"{url}/channel/leave/v1", json={
            'token': INVALID_TOKEN,
            'channel_id': channel_id1['channel_id']
        }).status_code == INPUT_ERROR
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7fbf3aa42048>('http://localhost:60811//channel/leave/v1', json={'channel_id': 183, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzZXNzaW9uX2lkIjo5OTk5fQ.DLVgZojClKM67VJkwqWJ9iyYG-qbWH1MHbGe0noFt-s'})
E        +      where <function post at 0x7fbf3aa42048> = requests.post

http_tests/channel_http_test.py:1094: AssertionError
_______________________________ test_empty_list ________________________________

clear = None

    def test_empty_list(clear):
        '''
        Tests for an empty list
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        channels = requests.get(f"{url}/channels/list/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
__________________________________ test_list ___________________________________

clear = None

    def test_list(clear):
        '''
        Basic test for functionality of channels/list/v2
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channels = requests.get(f"{url}/channels/list/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_____________________________ test_multiple_lists ______________________________

clear = None

    def test_multiple_lists(clear):
        '''
        Tests for multiple lists
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel2',
            'is_public': True
        })
        channels = requests.get(f"{url}/channels/list/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
__________________________ test_list_private_channel ___________________________

clear = None

    def test_list_private_channel(clear):
        '''
        Tests if private channels are listed properly
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': False
        })
        channels = requests.get(f"{url}/channels/list/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
________________________ test_channel_list_valid_token _________________________

clear = None

    def test_channel_list_valid_token(clear):
        '''
        Checks if token given is valid
        '''
        register_info = {
            'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZXNzaW9uX2lkIjo0fQ.UWh4yaDf6lPdmJroKBXfBZURXskoLULjM7Es_xZSK6U'
        }
>       assert requests.get(f"{url}/channels/list/v2", json={
            'token': register_info['token']
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//channels/list/v2', json={'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZXNzaW9uX2lkIjo0fQ.UWh4yaDf6lPdmJroKBXfBZURXskoLULjM7Es_xZSK6U'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/channels_http_test.py:99: AssertionError
______________________________ test_empty_listall ______________________________

clear = None

    def test_empty_listall(clear):
        '''
        Tests for an empty list
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        channels = requests.get(f"{url}/channels/listall/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_________________________________ test_listall _________________________________

clear = None

    def test_listall(clear):
        '''
        Basic test for channels/listall/v2
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channels = requests.get(f"{url}/channels/listall/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
____________________________ test_multiple_listall _____________________________

clear = None

    def test_multiple_listall(clear):
        '''
        Test multiple lists
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel2',
            'is_public': True
        })
        channels = requests.get(f"{url}/channels/listall/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_________________________ test_listall_private_channel _________________________

clear = None

    def test_listall_private_channel(clear):
        '''
        Tests if private channels appear in the list
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': False
        })
        channels = requests.get(f"{url}/channels/listall/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
___________________________ test_listall_valid_token ___________________________

clear = None

    def test_listall_valid_token(clear):
        '''
        Tests for an invalid token
        '''
        register_info = {
            'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZXNzaW9uX2lkIjo0fQ.UWh4yaDf6lPdmJroKBXfBZURXskoLULjM7Es_xZSK6U'
        }
>       assert requests.get(f"{url}/channels/listall/v2", json={
            'token': register_info['token']
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//channels/listall/v2', json={'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZXNzaW9uX2lkIjo0fQ.UWh4yaDf6lPdmJroKBXfBZURXskoLULjM7Es_xZSK6U'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/channels_http_test.py:187: AssertionError
_________________________________ test_create __________________________________

clear = None

    def test_create(clear):
        '''
        Basic test for functionality of channels/
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channels = requests.get(f"{url}/channels/listall/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________ test_channels_create_invalid_token ______________________

clear = None

    def test_channels_create_invalid_token(clear):
        '''
        Tests for invalid token
        '''
        register_info = {
            'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZXNzaW9uX2lkIjo0fQ.UWh4yaDf6lPdmJroKBXfBZURXskoLULjM7Es_xZSK6U'
        }
>       assert requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7fbf3aa42048>('http://localhost:60811//channels/create/v2', json={'is_public': True, 'name': 'Channel1', 'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZXNzaW9uX2lkIjo0fQ.UWh4yaDf6lPdmJroKBXfBZURXskoLULjM7Es_xZSK6U'})
E        +      where <function post at 0x7fbf3aa42048> = requests.post

http_tests/channels_http_test.py:234: AssertionError
________________________ test_dm_details_v1_input_error ________________________

clear = None
user_token1 = {'auth_user_id': 204, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIwNCwibG9naW5fdGltZSI6MTYxODI1NTAyMywic2FsdCI6IjMwYzM0M2EzLWJjNjEtNDdmMy1hNTQwLWY0YTllNjBmYWEwYiJ9.VfVd4Hdxld_jtV7AElKmWKSb83p1QbFIea1MNzsIUx4'}

    def test_dm_details_v1_input_error(clear, user_token1):
        """
        InputError to be thrown when DM ID is not a valid DM
        """
>       assert requests.get(f"{url}/dm/details/v1", json={
            'token': user_token1['token'],
            'dm_id': INVALID_ID
        }).status_code == INPUT_ERROR
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//dm/details/v1', json={'dm_id': 9999, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIwNCwibG9naW5fdGltZSI6MTYxODI1NTAyMywic2FsdCI6IjMwYzM0M2EzLWJjNjEtNDdmMy1hNTQwLWY0YTllNjBmYWEwYiJ9.VfVd4Hdxld_jtV7AElKmWKSb83p1QbFIea1MNzsIUx4'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/dm_http_test.py:98: AssertionError
_______________________ test_dm_details_v1_access_error ________________________

clear = None
unadded_user_token = {'auth_user_id': 208, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIwOCwibG9naW5fdGltZSI6MTYxODI1NTAyMywic2FsdCI6IjE3ODE2MzUwLTZjZGQtNDE1Zi05NWM1LTk1YTA2NDlmMTVmNyJ9.TmAroEO5uPLAS2iI2P5yFthYFGUolJnIr_EwChsn4gY'}
dm_1 = {'dm_id': 209, 'dm_name': 'godanliang, jeremylee, rolandlin'}

    def test_dm_details_v1_access_error(clear, unadded_user_token, dm_1):
        """
        AccessError to be thrown when authorised user is not a member of this DM with dm_id
        """
>       assert requests.get(f"{url}/dm/details/v1", json={
            'token': unadded_user_token['token'],
            'dm_id': dm_1['dm_id']
        }).status_code == ACCESS_ERROR
E       AssertionError: assert 500 == 403
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//dm/details/v1', json={'dm_id': 209, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIwOCwibG9naW5fdGltZSI6MTYxODI1NTAyMywic2FsdCI6IjE3ODE2MzUwLTZjZGQtNDE1Zi05NWM1LTk1YTA2NDlmMTVmNyJ9.TmAroEO5uPLAS2iI2P5yFthYFGUolJnIr_EwChsn4gY'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/dm_http_test.py:107: AssertionError
__________________________ test_dm_details_v1_simple ___________________________

clear = None
user_token1 = {'auth_user_id': 210, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIxMCwibG9naW5fdGltZSI6MTYxODI1NTAyMywic2FsdCI6IjJjMzllMzM3LWFlZmQtNDFiZi1hOTE1LTU1OWUzMzM3M2VhYyJ9.8aGausLQ2VDcSEFoNCr_XBkEu5chVz5x40HjVaznaHk'}
user_token2 = {'auth_user_id': 211, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIxMSwibG9naW5fdGltZSI6MTYxODI1NTAyMywic2FsdCI6IjdjZTc2YjNhLTcxNzAtNGE4Ni05MjUxLWFhMmQ3OThkMjczMSJ9.4xuf6PK6KuV2Cvcmv4rCguLrSSzDXHmAT2hVh5iGKkA'}
user_token3 = {'auth_user_id': 212, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIxMiwibG9naW5fdGltZSI6MTYxODI1NTAyMywic2FsdCI6ImU5OGQ1NDUyLWE3OGUtNDY3ZC05OWE5LTU2NTViMGE0ZTMzYSJ9.jYKbhggODYdNishZ6Pn_JLtEtIJy1bNVvWeK9MaGJx0'}
dm_1 = {'dm_id': 213, 'dm_name': 'godanliang, jeremylee, rolandlin'}

    def test_dm_details_v1_simple(clear, user_token1, user_token2, user_token3, dm_1):
        """
        Testing whether dm_details_v1 returns the correct name and members
        """
        dm_details = requests.get(f"{url}/dm/details/v1", json={
            'token': user_token1['token'],
>           'dm_id': dm_1['dm_id']
        }).json()

http_tests/dm_http_test.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
____________________________ test_dm_list_v1_simple ____________________________

clear = None
user_token1 = {'auth_user_id': 214, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIxNCwibG9naW5fdGltZSI6MTYxODI1NTAyMywic2FsdCI6Ijk1MDFmYTY5LWRlYzQtNGFiOS1hYjEzLWU5MTM1YjVjNjMxMCJ9.6DD7sw67l610OxOxCML0lWVcOnQ2y51NKFEup2yIsuE'}
dm_1 = {'dm_id': 217, 'dm_name': 'godanliang, jeremylee, rolandlin'}
dm_2 = {'dm_id': 218, 'dm_name': 'godanliang, jeremylee'}

    def test_dm_list_v1_simple(clear, user_token1, dm_1, dm_2):
        """
        Testing whether dm_list_v1 returns the list of DMs correctly
        """
        dms = requests.get(f"{url}/dm/list/v1", json={
>           'token': user_token1['token']
        }).json()

http_tests/dm_http_test.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
___________________________ test_dm_create_v1_simple ___________________________

clear = None
user_token1 = {'auth_user_id': 220, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIyMCwibG9naW5fdGltZSI6MTYxODI1NTAyMywic2FsdCI6ImZhODVlNjQ1LTRhZmItNDFkMy04MTUzLWQ5OGUxMGU0NTFhOSJ9.aerfUCuc3WqJ8zs1NSb5o4RqDujLYEQLoflxOp1RFAQ'}
user_token2 = {'auth_user_id': 221, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIyMSwibG9naW5fdGltZSI6MTYxODI1NTAyMywic2FsdCI6ImFiZmQyZjMwLTM2MWQtNGU1Yi1iMzAxLTQ1NDdjNjBmMzFmYSJ9.6VVZJVt7ru96oolIKrLNw0j-u5cvYOAeM2uYaKlLG-I'}
user_token3 = {'auth_user_id': 222, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIyMiwibG9naW5fdGltZSI6MTYxODI1NTAyMywic2FsdCI6IjhiM2ViMWYzLTlmZWMtNDViNi05NjMxLTRmZGIyZWI4MThkMSJ9.Cto-AjwBYaeVlm830pRzqp65AhgjlXmFEg_unjiiuR0'}

    def test_dm_create_v1_simple(clear, user_token1, user_token2, user_token3):
        """
        Testing whether dm_create_v1 returns the correct dm_id and dm_name
        """
        u_ids = [user_token2['auth_user_id'], user_token3['auth_user_id']]
        dm_1 = requests.post(f"{url}/dm/create/v1", json={
            'token': user_token1['token'],
            'u_ids': u_ids
        }).json()
>       assert dm_1['dm_id'] == 0
E       assert 223 == 0

http_tests/dm_http_test.py:190: AssertionError
______________________________ test_dm_remove_v1 _______________________________

clear = None
user_token1 = {'auth_user_id': 230, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIzMCwibG9naW5fdGltZSI6MTYxODI1NTAyMywic2FsdCI6IjU3MDkzZTQ3LWVhMzgtNDZlNy1hMzIyLTA1YTU2NDFmMTYzNSJ9.J7dUwMx5NCfc2cRoX4BN-fUSufLF0I0xEGp4WLCq2oY'}
dm_1 = {'dm_id': 233, 'dm_name': 'godanliang, jeremylee, rolandlin'}

    def test_dm_remove_v1(clear, user_token1, dm_1):
        """
        Testing whether dm is removed. If dm is removed, dm_details_v1 should raise
        InputError since dm is removed.
        """
        requests.delete(f"{url}/dm/remove/v1", json={
            'token': user_token1['token'],
            'dm_id': dm_1['dm_id']
        })
>       assert requests.get(f"{url}/dm/details/v1", json={
            'token': user_token1['token'],
            'dm_id': dm_1['dm_id']
        }).status_code == INPUT_ERROR
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//dm/details/v1', json={'dm_id': 233, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIzMCwibG9naW5fdGltZSI6MTYxODI1NTAyMywic2FsdCI6IjU3MDkzZTQ3LWVhMzgtNDZlNy1hMzIyLTA1YTU2NDFmMTYzNSJ9.J7dUwMx5NCfc2cRoX4BN-fUSufLF0I0xEGp4WLCq2oY'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/dm_http_test.py:239: AssertionError
__________________________ test_dm_invite_v1_Invite1 ___________________________

clear = None

    def test_dm_invite_v1_Invite1(clear):
        """
        Test whether user will be invited and added to the specified DM
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        requests.post(f"{url}/dm/invite/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'u_id': reg_info3['auth_user_id']
        })
        dm_details = requests.get(f"{url}/dm/details/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id']
        })
>       dm_details = dm_details.json()

http_tests/dm_http_test.py:431: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
__________________________ test_dm_invite_v1_Invite2 ___________________________

clear = None

    def test_dm_invite_v1_Invite2(clear):
        """
        Test whether two users can be invited and added to the specified DM properly
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        reg_info4 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Bolin@gmail.com',
            'password': 'password',
            'name_first': 'Bolin',
            'name_last': 'Ngo'
        })
        reg_info4 = reg_info4.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        requests.post(f"{url}/dm/invite/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'u_id': reg_info3['auth_user_id']
        })
        requests.post(f"{url}/dm/invite/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'u_id': reg_info4['auth_user_id']
        })
        dm_details = requests.get(f"{url}/dm/details/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id']
        })
>       dm_details = dm_details.json()

http_tests/dm_http_test.py:485: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
___________________________ test_dm_leave_v1_Leave1 ____________________________

clear = None

    def test_dm_leave_v1_Leave1(clear):
        """
        Test whether a user can leave the specified DM properly and changes are made
        If the most recent user has left properly, the -1 index of members will be of the previous user
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        requests.post(f"{url}/dm/invite/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'u_id': reg_info3['auth_user_id']
        })
        requests.post(f"{url}/dm/leave/v1", json={
            'token': reg_info3['token'],
            'dm_id': dm_2['dm_id']
        })
        dm_details = requests.get(f"{url}/dm/details/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id']
        })
>       dm_details = dm_details.json()

http_tests/dm_http_test.py:588: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
__________________________ test_dm_leave_v1_LeaveALL ___________________________

clear = None

    def test_dm_leave_v1_LeaveALL(clear):
        """
        Test whether multiple users can leave the specified DM properly
        If all members of the DM leave, the members list for that DM should be empty
        Therefore, calling dm_details_v1 for anyone should raise an AccessError as the user is no longer part of the DM
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        requests.post(f"{url}/dm/invite/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'u_id': reg_info3['auth_user_id']
        })
        requests.post(f"{url}/dm/leave/v1", json={
            'token': reg_info3['token'],
            'dm_id': dm_2['dm_id']
        })
        requests.post(f"{url}/dm/leave/v1", json={
            'token': reg_info2['token'],
            'dm_id': dm_2['dm_id']
        })
        requests.post(f"{url}/dm/leave/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id']
        })
>       assert requests.get(f"{url}/dm/details/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id']
        }).status_code == 403
E       AssertionError: assert 500 == 403
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//dm/details/v1', json={'dm_id': 270, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjI2NywibG9naW5fdGltZSI6MTYxODI1NTAyNCwic2FsdCI6ImRlYzNkMjJkLTFmNjktNDFjNi1hMDQ3LWM1OTdhNTQxOWExMCJ9.urbk4WhS6q1jT4J-0Cc7eu2-DEh-2ApetNtKWUjrCN4'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/dm_http_test.py:640: AssertionError
_______________________ test_dm_messages_v1_InputError1 ________________________

clear = None

    def test_dm_messages_v1_InputError1(clear):
        """
        InputError happens when dm_id does not refer to a existing DM
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
>       assert requests.get(f"{url}/dm/messages/v1", json={
            'token': reg_info1['token'],
            'dm_id': INVALID_ID,
            'start': 0
        }).status_code == 400
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//dm/messages/v1', json={'dm_id': 9999, 'start': 0, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjI3MSwibG9naW5fdGltZSI6MTYxODI1NTAyNCwic2FsdCI6ImQ4MzExNDkzLWM1ZTktNDk4ZS05N2ZiLWNjMjNlN2E3MWYxOSJ9.ZPMtNGLvigKTh4AT_GebUbQqDHOaYid2_YDmxK1eBAY'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/dm_http_test.py:668: AssertionError
_______________________ test_dm_messages_v1_InputError2 ________________________

clear = None

    def test_dm_messages_v1_InputError2(clear):
        """
        InputError happens when start is greater than total number of messages in
        the channel
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        message_id = requests.post(f"{url}/message/senddm/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'message': 'hi'
        })
        message_id = message_id.json()
>       assert requests.get(f"{url}/dm/messages/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'start': 1
        }).status_code == 400
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//dm/messages/v1', json={'dm_id': 274, 'start': 1, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjI3MiwibG9naW5fdGltZSI6MTYxODI1NTAyNCwic2FsdCI6IjAwMjQ5OTFjLWM4ZDktNDdmZC1hNTE0LTY0MjZkZjNjMjJiNiJ9.-gX63DzAR2KDEK2dF6ckLlMwg_Y_Tt5gPt9hYjJIryM'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/dm_http_test.py:704: AssertionError
_______________________ test_dm_messages_v1_AccessError ________________________

clear = None

    def test_dm_messages_v1_AccessError(clear):
        """
        AccessError happens when authorised user is not a member of the DM
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        message_id = requests.post(f"{url}/message/senddm/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'message': 'hi'
        })
        message_id = message_id.json()
>       assert requests.get(f"{url}/dm/messages/v1", json={
            'token': reg_info3['token'],
            'dm_id': dm_2['dm_id'],
            'start': 0
        }).status_code == 403
E       AssertionError: assert 500 == 403
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//dm/messages/v1', json={'dm_id': 279, 'start': 0, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjI3OCwibG9naW5fdGltZSI6MTYxODI1NTAyNCwic2FsdCI6IjhhYTk1NTczLTNiZDktNGY2OS1hOGMxLTQ1YjA1NThiY2U4OCJ9.mOgf1msBYc7a2Nk1hIqv5Dv4iYwFD1cAtXa7Ob28Ys4'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get

http_tests/dm_http_test.py:746: AssertionError
__________________________ test_dm_messages_v1_simple __________________________

clear = None

    def test_dm_messages_v1_simple(clear):
        """
        Test if -1 is returned if start + 50 surpasses total messages
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        message_id = requests.post(f"{url}/message/senddm/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'message': 'hi'
        })
        message_id = message_id.json()
        messages = requests.get(f"{url}/dm/messages/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/dm_http_test.py:786: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________ test_dm_messages_v1_many_messages _______________________

clear = None

    def test_dm_messages_v1_many_messages(clear):
        """
        Test that all messages are returned if start + 50 is within total
        messages in DM
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        for i in range(0, 50):
            message_id = requests.post(f"{url}/message/senddm/v1", json={
                'token': reg_info1['token'],
                'dm_id': dm_2['dm_id'],
                'message': f"message number {i}"
            })
            message_id = message_id.json()
        messages = requests.get(f"{url}/dm/messages/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/dm_http_test.py:826: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
__________________________________ test_echo ___________________________________

    def test_echo():
        '''
        A simple test to check echo
        '''
        resp = requests.get(config.url + 'echo', params={'data': 'hello'})
>       assert json.loads(resp.text) == {'data': 'hello'}

http_tests/echo_http_test.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fbf3c1570b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________________ test_message_send _______________________________

clear = None

    def test_message_send(clear):
        '''
        Basic test for functionality of message/send/v2
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
        requests.post(f"{url}/message/send/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'message': 'Hello'
        })
        messages = requests.get(f"{url}/channel/messages/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/message_http_test.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
________________________ test_message_send_input_error2 ________________________

clear = None

    def test_message_send_input_error2(clear):
        '''
        Tests for when no message is put in
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
>       assert requests.post(f"{url}/message/send/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'message': ''
        }).status_code == 400
E       AssertionError: assert 200 == 400
E        +  where 200 = <Response [200]>.status_code
E        +    where <Response [200]> = <function post at 0x7fbf3aa42048>('http://localhost:60811//message/send/v2', json={'channel_id': 344, 'message': '', 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM0MywibG9naW5fdGltZSI6MTYxODI1NTAyNCwic2FsdCI6ImU5ZWVmYTRkLTZhNzItNDQxYi1iZWI1LTk5MzJhZjBhM2RlMyJ9.Y2DsxGAZ9M7Q8vEl81s5Z0QDoKpwyFe2J7j4kTPCygI'})
E        +      where <function post at 0x7fbf3aa42048> = requests.post

http_tests/message_http_test.py:83: AssertionError
_______________________ test_message_send_invalid_token ________________________

clear = None

    def test_message_send_invalid_token(clear):
        '''
        Tests for invalid token
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
>       assert requests.post(f"{url}/message/send/v2", json={
            'token': 4,
            'channel_id': channel['channel_id'],
            'message': 'Hello'
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7fbf3aa42048>('http://localhost:60811//message/send/v2', json={'channel_id': 350, 'message': 'Hello', 'token': 4})
E        +      where <function post at 0x7fbf3aa42048> = requests.post

http_tests/message_http_test.py:134: AssertionError
______________________________ test_message_edit _______________________________

clear = None

    def test_message_edit(clear):
        '''
        Basic test for functionality of message/edit/v2
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
        message_id = requests.post(f"{url}/message/send/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'message': 'Hello'
        })
        message_id = message_id.json()
        print(message_id)
        requests.put(f"{url}/message/edit/v2", json={
            'token': register_info['token'],
            'message_id': message_id['message_id'],
            'message': '123'
        })
        messages = requests.get(f"{url}/channel/messages/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/message_http_test.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
----------------------------- Captured stdout call -----------------------------
{'message_id': 353}
__________________________ test_edit_message_no_error __________________________

clear = None

    def test_edit_message_no_error(clear):
        '''
        Checks to see if regular member can edit their message
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        register_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'roland@gmail.com',
            'password': '12345678',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        register_info2 = register_info2.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
        requests.post(f"{url}/channel/join/v2", json={
            'token': register_info2['token'],
            'channel_id': channel['channel_id']
        })
        message_id = requests.post(f"{url}/message/send/v2", json={
            'token': register_info2['token'],
            'channel_id': channel['channel_id'],
            'message': 'Hello'
        })
        message_id = message_id.json()
        requests.put(f"{url}/message/edit/v2", json={
            'token': register_info2['token'],
            'message_id': message_id['message_id'],
            'message': '123'
        })
        messages = requests.get(f"{url}/channel/messages/v2", json={
            'token': register_info2['token'],
            'channel_id': channel['channel_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/message_http_test.py:319: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_____________________________ test_message_remove ______________________________

clear = None

    def test_message_remove(clear):
        '''
        Basic test for message/remove/v2
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
        message_id = requests.post(f"{url}/message/send/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'message': 'Hello'
        })
        message_id = message_id.json()
        requests.delete(f"{url}/message/remove/v1", json={
            'token': register_info['token'],
            'message_id': message_id['message_id']
        })
        messages = requests.get(f"{url}/channel/messages/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/message_http_test.py:354: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
____________________________ test_message_remove_dm ____________________________

clear = None

    def test_message_remove_dm(clear):
        '''
        Tests removing a message from a dm
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        register_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'roland@gmail.com',
            'password': '12345678',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        register_info2 = register_info2.json()
        dm_info = requests.post(f"{url}/dm/create/v1", json={
            'token': register_info['token'],
            'u_ids': [register_info2['auth_user_id']]
        })
        dm_info = dm_info.json()
        message_info = requests.post(f"{url}/message/senddm/v1", json={
            'token': register_info['token'],
            'dm_id': dm_info['dm_id'],
            'message': 'Hello'
        })
        message_info = message_info.json()
        requests.delete(f"{url}/message/remove/v1", json={
            'token': register_info['token'],
            'message_id': message_info['message_id'],
        })
        messages = requests.get(f"{url}/dm/messages/v1", json={
            'token': register_info['token'],
            'dm_id': dm_info['dm_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/message_http_test.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________________ test_message_share ______________________________

clear = None

    def test_message_share(clear):
        '''
        Basic testfor message/share/v2
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
        channel2 = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel2',
            'is_public': True
        })
        channel2 = channel2.json()
        message_info = requests.post(f"{url}/message/send/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'message': 'Hello'
        })
        message_info = message_info.json()
        requests.post(f"{url}/message/share/v1", json={
            'token': register_info['token'],
            'og_message_id': message_info['message_id'],
            'message': '123',
            'channel_id': channel2['channel_id'],
            'dm_id': -1
        })
        messages = requests.get(f"{url}/channel/messages/v2", json={
            'token': register_info['token'],
            'channel_id': channel2['channel_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/message_http_test.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_message_share_invalid_token _______________________

clear = None

    def test_message_share_invalid_token(clear):
        '''
        Tests for invalid token
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
        channel2 = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel2',
            'is_public': True
        })
        channel2 = channel2.json()
        message_info = requests.post(f"{url}/message/send/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'message': 'Hello'
        })
        message_info = message_info.json()
>       assert requests.post(f"{url}/message/share/v1", json={
            'token': 1,
            'og_message_id': message_info['message_id'],
            'message': '123',
            'channel_id': channel2['channel_id'],
            'dm_id': -1
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7fbf3aa42048>('http://localhost:60811//message/share/v1', json={'channel_id': 394, 'dm_id': -1, 'message': '123', 'og_message_id': 395, ...})
E        +      where <function post at 0x7fbf3aa42048> = requests.post

http_tests/message_http_test.py:581: AssertionError
_____________________________ test_message_senddm ______________________________

clear = None

    def test_message_senddm(clear):
        '''
        Basic test for functionality of message/senddm/v2
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        register_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'roland@gmail.com',
            'password': '12345678',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        register_info2 = register_info2.json()
        dm_info = requests.post(f"{url}/dm/create/v1", json={
            'token': register_info['token'],
            'u_ids': [register_info2['auth_user_id']]
        })
        dm_info = dm_info.json()
        requests.post(f"{url}/message/senddm/v1", json={
            'token': register_info['token'],
            'dm_id': dm_info['dm_id'],
            'message': 'Hello'
        })
        messages = requests.get(f"{url}/dm/messages/v1", json={
            'token': register_info['token'],
            'dm_id': dm_info['dm_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/message_http_test.py:662: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________ test_message_senddm_invalid_token _______________________

clear = None

    def test_message_senddm_invalid_token(clear):
        '''
        Tests for invalid token
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        register_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'roland@gmail.com',
            'password': '12345678',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        register_info2 = register_info2.json()
        dm_info = requests.post(f"{url}/dm/create/v1", json={
            'token': register_info['token'],
            'u_ids': [register_info2['auth_user_id']]
        })
        dm_info = dm_info.json()
>       assert requests.post(f"{url}/message/senddm/v1", json={
            'token': 1,
            'dm_id': dm_info['dm_id'],
            'message': 'Hello'
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7fbf3aa42048>('http://localhost:60811//message/senddm/v1', json={'dm_id': 409, 'message': 'Hello', 'token': 1})
E        +      where <function post at 0x7fbf3aa42048> = requests.post

http_tests/message_http_test.py:750: AssertionError
________________________________ test_search_v2 ________________________________

clear_data = None

    def test_search_v2(clear_data):
        '''
        Basic test for functionality of search function
        '''
        user = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'skadi@gmail.com',
            'password': '1234aaaaaa',
            'name_first': 'Tom',
            'name_last': 'Diaaa',
        })
        user_pl = user.json()
    
        channel_info = requests.post(config.url + 'channels/create/v2', json = {
            'token': user_pl['token'],
            'name': 'Channel1',
            'is_public': True,
        })
        channel_info_pl = channel_info.json()
    
        requests.post(config.url + 'message/send/v2', json = {
            'token': user_pl['token'],
            'channel_id': channel_info_pl['channel_id'],
            'message': 'Hello',
        })
    
>       assert requests.get(config.url + 'search/v2', json = {
            'token': user_pl['token'],
            'query_str': 'Hello',
        }).status_code == 200
E       AssertionError: assert 403 == 200
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function get at 0x7fbf3aa40e18>(('http://localhost:60811/' + 'search/v2'), json={'query_str': 'Hello', 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQxMCwibG9naW5fdGltZSI6MTYxODI1NTAyNSwic2FsdCI6ImEzM2Q4NjQyLTEzNDktNGVkYy1iNmNkLTY1ODc4ZGY5YWVjOCJ9.Aj2sG_L0QQh75rQl2lTR-Tpan6U7K06cIcDBXB_aXoY'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get
E        +      and   'http://localhost:60811/' = config.url

http_tests/other_http_test.py:47: AssertionError
__________________________ test_search_v2_input_error __________________________

clear_data = None

    def test_search_v2_input_error(clear_data):
        '''
        Test for invalid query_str in search function
        '''
        user = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'skadi@gmail.com',
            'password': '1234aaaaaa',
            'name_first': 'Sing',
            'name_last': 'Diaaa',
        })
        user_pl = user.json()
    
        channel_info = requests.post(config.url + 'channels/create/v2', json = {
            'token': user_pl['token'],
            'name': 'Channel1',
            'is_public': True,
        })
        channel_info_pl = channel_info.json()
    
        requests.post(config.url + 'message/send/v2', json = {
            'token': user_pl['token'],
            'channel_id': channel_info_pl['channel_id'],
            'message': 'Hello',
        })
    
>       assert requests.get(config.url + 'search/v2', json = {
            'token': user_pl['token'],
            'query_str':'Hello' * 1000,
        }).status_code == InputError.code
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function get at 0x7fbf3aa40e18>(('http://localhost:60811/' + 'search/v2'), json={'query_str': 'HelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHel...xODI1NTAyNSwic2FsdCI6Ijk5OGIyNjFmLTk4Y2YtNGY1Yy04YzQyLTU0YTQ5NmE3ZDVmYyJ9.fIFNsuT9X2H5f-v3myTkUngeHlOMAe9Y3Xp6opWHlQ8'})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get
E        +      and   'http://localhost:60811/' = config.url
E        +  and   400 = InputError.code

http_tests/other_http_test.py:77: AssertionError
__________________________ test_notifications_get_tag __________________________

clear_data = None

    def test_notifications_get_tag(clear_data):
        '''
        Test if user got tagged in channel
        '''
        user = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'gordon@gmail.com',
            'password': '1234aaaaaa',
            'name_first': 'Gordon',
            'name_last': 'Liang',
        })
        user_pl = user.json()
    
        channel_info = requests.post(config.url + 'channels/create/v2', json = {
            'token': user_pl['token'],
            'name': 'Channel1',
            'is_public': True,
        })
        channel_info_pl = channel_info.json()
    
        requests.post(config.url + 'message/send/v2', json = {
            'token': user_pl['token'],
            'channel_id': channel_info_pl['channel_id'],
            'message': 'Hello @gordonliang',
        })
    
        notification = requests.get(config.url + 'notifications/get/v1', json = {
            'token': user_pl['token'],
        })
>       notification_pl = notification.json()

http_tests/other_http_test.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
____________________ test_notifications_get_add_to_channel _____________________

clear_data = None

    def test_notifications_get_add_to_channel(clear_data):
        '''
        Test if user got added in channel
        '''
        user = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'gordon@gmail.com',
            'password': '1234aaaaaa',
            'name_first': 'Gordon',
            'name_last': 'Liang',
        })
        user_pl = user.json()
    
        user2 = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'kanit@gmail.com',
            'password': '12345678',
            'name_first': 'Kanit',
            'name_last': 'Srihakorth',
        })
        user2_pl = user2.json()
    
        channel_info = requests.post(config.url + 'channels/create/v2', json = {
            'token': user_pl['token'],
            'name': 'Channel1',
            'is_public': True,
        })
        channel_info_pl = channel_info.json()
    
        requests.post(config.url + 'channel/invite/v2', json = {
            'token': user_pl['token'],
            'channel_id': channel_info_pl['channel_id'],
            'u_id': user2_pl['auth_user_id'],
        })
    
        notification = requests.get(config.url + 'notifications/get/v1', json = {
            'token': user2_pl['token'],
        })
>       notification_pl = notification.json()

http_tests/other_http_test.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
________________________ test_notifications_get_tag_dm _________________________

clear_data = None

    def test_notifications_get_tag_dm(clear_data):
        '''
        Test if user got tagged in dm
        '''
        user = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'gordon@gmail.com',
            'password': '1234aaaaaa',
            'name_first': 'Gordon',
            'name_last': 'Liang',
        })
        user_pl = user.json()
    
        user2 = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'kanit@gmail.com',
            'password': '12345678',
            'name_first': 'Kanit',
            'name_last': 'Srihakorth',
        })
        user2_pl = user2.json()
    
        dm_info = requests.post(config.url + 'dm/create/v1', json = {
            'token': user_pl['token'],
            'u_ids': [user2_pl['auth_user_id']],
        })
        dm_info_pl = dm_info.json()
    
        requests.post(config.url + 'message/senddm/v1', json = {
            'token': user_pl['token'],
            'dm_id': dm_info_pl['dm_id'],
            'message': 'Hello @kanitsrihakorth',
        })
    
        notification = requests.get(config.url + 'notifications/get/v1', json = {
            'token': user2_pl['token'],
        })
>       notification_pl = notification.json()

http_tests/other_http_test.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_notifications_get_add_to_dm _______________________

clear_data = None

    def test_notifications_get_add_to_dm(clear_data):
        '''
        Test if user got added in dm
        '''
        user = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'gordon@gmail.com',
            'password': '1234aaaaaa',
            'name_first': 'Gordon',
            'name_last': 'Liang',
        })
        user_pl = user.json()
    
        user2 = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'kanit@gmail.com',
            'password': '12345678',
            'name_first': 'Kanit',
            'name_last': 'Srihakorth',
        })
        user2_pl = user2.json()
    
        requests.post(config.url + 'dm/create/v1', json = {
            'token': user_pl['token'],
            'u_ids': [user2_pl['auth_user_id']],
        })
    
        notification = requests.get(config.url + 'notifications/get/v1', json = {
            'token': user2_pl['token'],
        })
>       notification_pl = notification.json()

http_tests/other_http_test.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fbf3ada77b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fbf3bb2bc30>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________________ test_invalid_uid _______________________________

clear_data = None

    def test_invalid_uid(clear_data):
        r = requests.post(f'{url}/auth/register/v2', json={
            'email': 'tom@gmail.com',
            'password': 'hello1234',
            'name_first': 'tom',
            'name_last': 'brown',
        })
        payload = r.json()
>       assert requests.get(f'{url}/user/profile/v2', json={
            'token': payload['token'],
            'u_id': 10000
        }).status_code == InputError.code
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//user/profile/v2', json={'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQyOSwibG9naW5fdGltZSI6MTYxODI1NTAyNiwic2FsdCI6IjQyYmI2N2FiLTEwMmMtNDA4OC05YWFjLTQ2YTQ3YTYyZGQyMSJ9.08MQUn1ogf_Y6-XNZLLG9C6zoYVuNpcvI4gEWn74YQk', 'u_id': 10000})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get
E        +  and   400 = InputError.code

http_tests/user_http_test.py:29: AssertionError
__________________________ test_invalid_token_profile __________________________

clear_data = None

    def test_invalid_token_profile(clear_data):
        user = requests.post(f'{url}/auth/register/v2', json={
            'email': 'tom@gmail.com',
            'password': 'hello1234',
            'name_first': 'tom',
            'name_last': 'brown',
        }).json()
    
>       assert requests.get(f'{url}/user/profile/v2', json={
            'token': 'invalid_token',
            'u_id': user['auth_user_id']
        }).status_code == AccessError.code
E       AssertionError: assert 500 == 403
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7fbf3aa40e18>('http://localhost:60811//user/profile/v2', json={'token': 'invalid_token', 'u_id': 430})
E        +      where <function get at 0x7fbf3aa40e18> = requests.get
E        +  and   403 = AccessError.code

http_tests/user_http_test.py:43: AssertionError
________________________________ test_all_users ________________________________

clear_data = None

    def test_all_users(clear_data):
        r = requests.post(f'{url}/auth/register/v2', json={
            'email': 'tom@gmail.com',
            'password': 'hello1234',
            'name_first': 'tom',
            'name_last': 'brown',
        })
        payload = r.json()
        requests.post(f'{url}/auth/register/v2', json={
            'email': 'rob@gmail.com',
            'password': 'hello1234',
            'name_first': 'rob',
            'name_last': 'blue',
        })
        query_string = f"token={payload['token']}"
        users = requests.get(f'{url}/users/all/v1?{query_string}')
        payload2 = users.json()
>       assert len(payload2) == 2
E       AssertionError: assert 1 == 2
E        +  where 1 = len({'users': [{'email': 'tom@gmail.com', 'handle_str': 'tombrown', 'name_first': 'tom', 'name_last': 'brown', ...}, {'email': 'rob@gmail.com', 'handle_str': 'robblue', 'name_first': 'rob', 'name_last': 'blue', ...}]})

http_tests/user_http_test.py:209: AssertionError
=========================== short test summary info ============================
FAILED http_tests/admin_http_test.py::test_invalid_permissin_id_admin_userpermission_change_v1
FAILED http_tests/auth_http_test.py::test_invalid_token_logout - AssertionErr...
FAILED http_tests/channel_http_test.py::test_channel_invite_v1_AccessErr - As...
FAILED http_tests/channel_http_test.py::test_channel_invite_v1_AddMulti - sim...
FAILED http_tests/channel_http_test.py::test_channel_invite_invalid_token - A...
FAILED http_tests/channel_http_test.py::test_channel_details_v1_InputErr - As...
FAILED http_tests/channel_http_test.py::test_channel_details_v1_AccessErr - A...
FAILED http_tests/channel_http_test.py::test_channel_details_v1_OneInv - simp...
FAILED http_tests/channel_http_test.py::test_channel_details_invalid_token - ...
FAILED http_tests/channel_http_test.py::test_channel_messages_v1_input_error1
FAILED http_tests/channel_http_test.py::test_channel_messages_v1_input_error2
FAILED http_tests/channel_http_test.py::test_channel_messages_v1_access_error
FAILED http_tests/channel_http_test.py::test_channel_messages_v1_simple - sim...
FAILED http_tests/channel_http_test.py::test_channel_messages_v1_many - simpl...
FAILED http_tests/channel_http_test.py::test_channel_messages_invalid_token
FAILED http_tests/channel_http_test.py::test_channel_join_v1_empty_channel - ...
FAILED http_tests/channel_http_test.py::test_channel_join_v1_check_details - ...
FAILED http_tests/channel_http_test.py::test_channel_join_invalid_token - Ass...
FAILED http_tests/channel_http_test.py::test_channel_join_owner_perm - simple...
FAILED http_tests/channel_http_test.py::test_channel_addowner_v1_AddMulti - s...
FAILED http_tests/channel_http_test.py::test_channel_addowner_invalid_token
FAILED http_tests/channel_http_test.py::test_channel_removeowner_v1_RemoveMulti
FAILED http_tests/channel_http_test.py::test_channel_removeowner_invalid_token
FAILED http_tests/channel_http_test.py::test_channel_leave_v1_Leave1 - simple...
FAILED http_tests/channel_http_test.py::test_channel_leave_v1_LeaveMulti - si...
FAILED http_tests/channel_http_test.py::test_channel_leave_v1_LeaveOwner - si...
FAILED http_tests/channel_http_test.py::test_channel_leave_v1_last_owner - si...
FAILED http_tests/channel_http_test.py::test_channel_leave_invalid_token - As...
FAILED http_tests/channels_http_test.py::test_empty_list - simplejson.errors....
FAILED http_tests/channels_http_test.py::test_list - simplejson.errors.JSONDe...
FAILED http_tests/channels_http_test.py::test_multiple_lists - simplejson.err...
FAILED http_tests/channels_http_test.py::test_list_private_channel - simplejs...
FAILED http_tests/channels_http_test.py::test_channel_list_valid_token - Asse...
FAILED http_tests/channels_http_test.py::test_empty_listall - simplejson.erro...
FAILED http_tests/channels_http_test.py::test_listall - simplejson.errors.JSO...
FAILED http_tests/channels_http_test.py::test_multiple_listall - simplejson.e...
FAILED http_tests/channels_http_test.py::test_listall_private_channel - simpl...
FAILED http_tests/channels_http_test.py::test_listall_valid_token - Assertion...
FAILED http_tests/channels_http_test.py::test_create - simplejson.errors.JSON...
FAILED http_tests/channels_http_test.py::test_channels_create_invalid_token
FAILED http_tests/dm_http_test.py::test_dm_details_v1_input_error - Assertion...
FAILED http_tests/dm_http_test.py::test_dm_details_v1_access_error - Assertio...
FAILED http_tests/dm_http_test.py::test_dm_details_v1_simple - simplejson.err...
FAILED http_tests/dm_http_test.py::test_dm_list_v1_simple - simplejson.errors...
FAILED http_tests/dm_http_test.py::test_dm_create_v1_simple - assert 223 == 0
FAILED http_tests/dm_http_test.py::test_dm_remove_v1 - AssertionError: assert...
FAILED http_tests/dm_http_test.py::test_dm_invite_v1_Invite1 - simplejson.err...
FAILED http_tests/dm_http_test.py::test_dm_invite_v1_Invite2 - simplejson.err...
FAILED http_tests/dm_http_test.py::test_dm_leave_v1_Leave1 - simplejson.error...
FAILED http_tests/dm_http_test.py::test_dm_leave_v1_LeaveALL - AssertionError...
FAILED http_tests/dm_http_test.py::test_dm_messages_v1_InputError1 - Assertio...
FAILED http_tests/dm_http_test.py::test_dm_messages_v1_InputError2 - Assertio...
FAILED http_tests/dm_http_test.py::test_dm_messages_v1_AccessError - Assertio...
FAILED http_tests/dm_http_test.py::test_dm_messages_v1_simple - simplejson.er...
FAILED http_tests/dm_http_test.py::test_dm_messages_v1_many_messages - simple...
FAILED http_tests/echo_http_test.py::test_echo - json.decoder.JSONDecodeError...
FAILED http_tests/message_http_test.py::test_message_send - simplejson.errors...
FAILED http_tests/message_http_test.py::test_message_send_input_error2 - Asse...
FAILED http_tests/message_http_test.py::test_message_send_invalid_token - Ass...
FAILED http_tests/message_http_test.py::test_message_edit - simplejson.errors...
FAILED http_tests/message_http_test.py::test_edit_message_no_error - simplejs...
FAILED http_tests/message_http_test.py::test_message_remove - simplejson.erro...
FAILED http_tests/message_http_test.py::test_message_remove_dm - simplejson.e...
FAILED http_tests/message_http_test.py::test_message_share - simplejson.error...
FAILED http_tests/message_http_test.py::test_message_share_invalid_token - As...
FAILED http_tests/message_http_test.py::test_message_senddm - simplejson.erro...
FAILED http_tests/message_http_test.py::test_message_senddm_invalid_token - A...
FAILED http_tests/other_http_test.py::test_search_v2 - AssertionError: assert...
FAILED http_tests/other_http_test.py::test_search_v2_input_error - AssertionE...
FAILED http_tests/other_http_test.py::test_notifications_get_tag - simplejson...
FAILED http_tests/other_http_test.py::test_notifications_get_add_to_channel
FAILED http_tests/other_http_test.py::test_notifications_get_tag_dm - simplej...
FAILED http_tests/other_http_test.py::test_notifications_get_add_to_dm - simp...
FAILED http_tests/user_http_test.py::test_invalid_uid - AssertionError: asser...
FAILED http_tests/user_http_test.py::test_invalid_token_profile - AssertionEr...
FAILED http_tests/user_http_test.py::test_all_users - AssertionError: assert ...
======================== 76 failed, 240 passed in 6.97s ========================
