============================= test session starts ==============================
platform linux -- Python 3.7.3, pytest-6.2.3, py-1.10.0, pluggy-0.13.1
rootdir: /tmp_amd/kamen/export/kamen/3/cs1531/automark/tempstore, configfile: pytest.ini
plugins: forked-1.3.0, xdist-2.2.1, hypothesis-6.1.1, timeout-1.4.2
collected 145 items

http_tests/admin_http_test.py ......F......F                             [  4%]
http_tests/auth_http_test.py ...........                                 [ 12%]
http_tests/channel_http_test.py ...FFFFFFFFFFFFFF..FFF...FF....FF..FFFFF [ 40%]
                                                                         [ 40%]
http_tests/channels_http_test.py FFFFFFFFFFF.F                           [ 48%]
http_tests/dm_http_test.py FFFF.F..F....FF..FFFFFFF                      [ 65%]
http_tests/echo_http_test.py F                                           [ 66%]
http_tests/message_http_test.py F.F.FF...FF..FF.FF..F                    [ 80%]
http_tests/other_http_test.py FF..FFFF                                   [ 86%]
http_tests/user_http_test.py FF.........F.

=================================== FAILURES ===================================
___________ test_invalid_permissin_id_admin_userpermission_change_v1 ___________

clear_data = None

    def test_invalid_permissin_id_admin_userpermission_change_v1(clear_data):
        '''
        Test if admin_userpermission_change function permissin_id is invalid
        '''
        user1 = requests.post(f'{url}/auth/register/v2', json = {
            'email': 'ska@gmail.com',
            'password': '1234aaaaaa',
            'name_first': 'Tom',
            'name_last': 'diaaa',
        })
        user2 = requests.post(f'{url}/auth/register/v2', json = {
            'email': 'skad@gmail.com',
            'password': '1234aasaaaa',
            'name_first': 'Brown',
            'name_last': 'diaam',
        })
        payload1 = user1.json()
        payload2 = user2.json()
>       assert requests.post(f'{url}/admin/userpermission/change/v1', json = {
            'token' : payload1['token'],
            'u_id' : payload2['auth_user_id'],
            'permission_id' : 999,
        }).status_code == AccessError.code
E       AssertionError: assert 400 == 403
E        +  where 400 = <Response [400]>.status_code
E        +    where <Response [400]> = <function post at 0x7f7f8f7e5e18>('http://127.0.0.1:6080//admin/userpermission/change/v1', json={'permission_id': 999, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjEyLCJsb2dpbl90aW1lIjoxNjE5MTg4MTY3LCJzYWx0IjoiYTMxZTM5YzItNWY1YS00YTIxLTllYWUtM2VlZDk3MjUyZWY2In0.BW5-Qza69FFRg37kTXb6K3OEaSFAMVXjSUnUCkZ6CrU', 'u_id': 13})
E        +      where <function post at 0x7f7f8f7e5e18> = requests.post
E        +  and   403 = AccessError.code

http_tests/admin_http_test.py:190: AssertionError
___________ test_invalid_permissin_id_admin_userpermission_change_v1 ___________

clear_data = None

    def test_invalid_permissin_id_admin_userpermission_change_v1(clear_data):
        '''
        Test if admin_userpermission_change function permissin_id is invalid
        '''
        user1 = requests.post(f'{url}/auth/register/v2', json = {
            'email': 'ska@gmail.com',
            'password': '1234aaaaaa',
            'name_first': 'Tom',
            'name_last': 'diaaa',
        })
        user2 = requests.post(f'{url}/auth/register/v2', json = {
            'email': 'skad@gmail.com',
            'password': '1234aasaaaa',
            'name_first': 'Brown',
            'name_last': 'diaam',
        })
        payload1 = user1.json()
        payload2 = user2.json()
>       assert requests.post(f'{url}/admin/userpermission/change/v1', json = {
            'token' : payload1['token'],
            'u_id' : payload2['auth_user_id'],
            'permission_id' : 999,
        }).status_code == AccessError.code
E       AssertionError: assert 400 == 403
E        +  where 400 = <Response [400]>.status_code
E        +    where <Response [400]> = <function post at 0x7f7f8f7e5e18>('http://127.0.0.1:6080//admin/userpermission/change/v1', json={'permission_id': 999, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjI2LCJsb2dpbl90aW1lIjoxNjE5MTg4MTY4LCJzYWx0IjoiNmYzNDI0YWUtZjE1My00NzVmLWExOTMtZGNkMzZmMjllMDM5In0.vPq1Jz7Q8TH8KU0BPuKdFRbSQZCODkT6V3SEGA-gL0o', 'u_id': 27})
E        +      where <function post at 0x7f7f8f7e5e18> = requests.post
E        +  and   403 = AccessError.code

http_tests/admin_http_test.py:190: AssertionError
_______________________ test_channel_invite_v1_AccessErr _______________________

clear = None

    def test_channel_invite_v1_AccessErr(clear):
        """
        AccessError happens when auth is not in channel for invite
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
>       assert requests.post(f"{url}/channel/invite/v2", json={
            'token': reg_info2['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info1['auth_user_id']
        }).status_code == 403
E       AssertionError: assert 400 == 403
E        +  where 400 = <Response [400]>.status_code
E        +    where <Response [400]> = <function post at 0x7f7f8f7e5e18>('http://127.0.0.1:6080//channel/invite/v2', json={'channel_id': 46, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQ1LCJsb2dpbl90aW1lIjoxNjE5MTg4MTY4LCJzYWx0IjoiNjFiZjhjMGEtMGE5ZC00MTRlLWIzYjAtOTQ3MDVkZjA4OGEyIn0.7AKJsD7TkmWygs1yjGmte1EQgGn_UNdSeg0eF0fIk_w', 'u_id': 44})
E        +      where <function post at 0x7f7f8f7e5e18> = requests.post

http_tests/channel_http_test.py:207: AssertionError
_______________________ test_channel_invite_v1_AddMulti ________________________

clear = None

    def test_channel_invite_v1_AddMulti(clear):
        """
        Tests that multiple users can be added to channel for invite
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
        requests.post(f"{url}/channel/invite/v2", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info2['auth_user_id']
        })
        requests.post(f"{url}/channel/invite/v2", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info3['auth_user_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id']
        })
>       channel_details1 = channel_details1.json()

http_tests/channel_http_test.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________ test_channel_invite_invalid_token _______________________

clear = None

    def test_channel_invite_invalid_token(clear):
        """
        Test invalid token for invite
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
>       assert requests.post(f"{url}/channel/invite/v2", json={
            'token': 'invalid_token',
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info1['auth_user_id']
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7f7f8f7e5e18>('http://127.0.0.1:6080//channel/invite/v2', json={'channel_id': 52, 'token': 'invalid_token', 'u_id': 51})
E        +      where <function post at 0x7f7f8f7e5e18> = requests.post

http_tests/channel_http_test.py:279: AssertionError
_______________________ test_channel_details_v1_InputErr _______________________

clear = None

    def test_channel_details_v1_InputErr(clear):
        """
        InputError happens when channel_id is invalid
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
>       assert requests.get(f"{url}/channel/details/v2", json={
            'token': reg_info1['token'],
            'channel_id': INVALID_ID
        }).status_code == 400
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//channel/details/v2', json={'channel_id': 9999, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjUzLCJsb2dpbl90aW1lIjoxNjE5MTg4MTY4LCJzYWx0IjoiZDc3ZGZhNWUtMDQ3MS00N2RhLWFiMjYtOTNmNjc1ZDM0YmQxIn0.ZH66uBhON8Yu1XXX-jpIduNfckabZ_YHl-ilFIH3e80'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/channel_http_test.py:300: AssertionError
______________________ test_channel_details_v1_AccessErr _______________________

clear = None

    def test_channel_details_v1_AccessErr(clear):
        """
        AccessError happens when auth is not in channel
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
>       assert requests.get(f"{url}/channel/details/v2", json={
            'token': reg_info2['token'],
            'channel_id': channel_id1['channel_id']
        }).status_code == 403
E       AssertionError: assert 500 == 403
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//channel/details/v2', json={'channel_id': 56, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjU1LCJsb2dpbl90aW1lIjoxNjE5MTg4MTY4LCJzYWx0IjoiMDU3MDY1MjYtZmUzNS00ZTUxLWFmNzktNmZkZWIyZmY1ZGI0In0.uhtXO2f2m5F0141X9d7I6verVoYKPAgnTTbBAkS3_mU'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/channel_http_test.py:329: AssertionError
________________________ test_channel_details_v1_OneInv ________________________

clear = None

    def test_channel_details_v1_OneInv(clear):
        """
        Tests that correct details are provided when calling function for details
        After inviting one user
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
        requests.post(f"{url}/channel/invite/v2", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info2['auth_user_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id']
        })
>       channel_details1 = channel_details1.json()

http_tests/channel_http_test.py:368: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________ test_channel_details_invalid_token ______________________

clear = None

    def test_channel_details_invalid_token(clear):
        """
        Test invalid token for details
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
>       assert requests.get(f"{url}/channel/details/v2", json={
            'token': 'invalid_token',
            'channel_id': channel_id1['channel_id']
        }).status_code == 400
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//channel/details/v2', json={'channel_id': 61, 'token': 'invalid_token'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/channel_http_test.py:391: AssertionError
____________________ test_channel_messages_v1_input_error1 _____________________

clear = None
user_token1 = {'auth_user_id': 62, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjYyLCJsb2dpbl90aW1lIjoxNjE5MTg4MTY4LCJzYWx0IjoiZTIyYmE3NTEtNmVmZi00MjZhLWEzYzQtNzgwYThlNWU5NGMxIn0.rtyS0lt3xHnd_B-btjoCmoc3jdTmhJQ6JOfagWMxoYA'}
public_channel = {'channel_id': 63}

    def test_channel_messages_v1_input_error1(clear, user_token1, public_channel):
        """
        InputError to be thrown when channel_id is invalid
        """
        start = 0
>       assert requests.get(f"{url}/channel/messages/v2", json={
            'token': user_token1['token'],
            'channel_id': INVALID_ID,
            'start': start
        }).status_code == INPUT_ERROR
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//channel/messages/v2', json={'channel_id': 9999, 'start': 0, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjYyLCJsb2dpbl90aW1lIjoxNjE5MTg4MTY4LCJzYWx0IjoiZTIyYmE3NTEtNmVmZi00MjZhLWEzYzQtNzgwYThlNWU5NGMxIn0.rtyS0lt3xHnd_B-btjoCmoc3jdTmhJQ6JOfagWMxoYA'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/channel_http_test.py:405: AssertionError
____________________ test_channel_messages_v1_input_error2 _____________________

clear = None
user_token1 = {'auth_user_id': 64, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjY0LCJsb2dpbl90aW1lIjoxNjE5MTg4MTY4LCJzYWx0IjoiNTIyMWY1YWQtMzA2Mi00ZGYzLWExOGYtYzk1MjRjNzkyODQzIn0.szn3y4gYuxbVEsv10JY6TDeabhwvkQrK3kElCnxWsTU'}
public_channel = {'channel_id': 65}

    def test_channel_messages_v1_input_error2(clear, user_token1, public_channel):
        """
        InputError2 to be thrown when start is greater than number of messages in channel
        """
        channel_id = public_channel['channel_id']
        requests.post(f"{url}/message/send/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id,
            'message': "Hello"
        }).json()
        start = 1
>       assert requests.get(f"{url}/channel/messages/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id,
            'start': start
        }).status_code == INPUT_ERROR
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//channel/messages/v2', json={'channel_id': 65, 'start': 1, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjY0LCJsb2dpbl90aW1lIjoxNjE5MTg4MTY4LCJzYWx0IjoiNTIyMWY1YWQtMzA2Mi00ZGYzLWExOGYtYzk1MjRjNzkyODQzIn0.szn3y4gYuxbVEsv10JY6TDeabhwvkQrK3kElCnxWsTU'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/channel_http_test.py:422: AssertionError
____________________ test_channel_messages_v1_access_error _____________________

clear = None
user_token1 = {'auth_user_id': 67, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjY3LCJsb2dpbl90aW1lIjoxNjE5MTg4MTY4LCJzYWx0IjoiYzk1ZDVkMjItNTY4NC00NDcxLTgyZDYtODc3MGQxNzFiOTJhIn0.MrxKQfrLWkqZHW6ebGshJEO__frpOIXbyVpILfvGhtg'}
user_token2 = {'auth_user_id': 68, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjY4LCJsb2dpbl90aW1lIjoxNjE5MTg4MTY4LCJzYWx0IjoiMTc4N2VjNWEtMzZlMi00MDlkLTk0ODktMTMyOTFjMzkxZjlkIn0.-HH1A6JU-cTtq4DKIsXQChltrdVZu8Wk_VuYaNCEGew'}
public_channel = {'channel_id': 69}

    def test_channel_messages_v1_access_error(clear, user_token1, user_token2, public_channel):
        """
        Accessing auth_user2's messages should throw an Access Error since only
        user_token1 is in the channel (added during public_channel function)
        """
        channel_id = public_channel['channel_id']
        requests.post(f"{url}/message/send/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id,
            'message': "Hello"
        }).json()
        start = 0
>       assert requests.get(f"{url}/channel/messages/v2", json={
            'token': user_token2['token'],
            'channel_id': channel_id,
            'start': start
        }).status_code == ACCESS_ERROR
E       AssertionError: assert 500 == 403
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//channel/messages/v2', json={'channel_id': 69, 'start': 0, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjY4LCJsb2dpbl90aW1lIjoxNjE5MTg4MTY4LCJzYWx0IjoiMTc4N2VjNWEtMzZlMi00MDlkLTk0ODktMTMyOTFjMzkxZjlkIn0.-HH1A6JU-cTtq4DKIsXQChltrdVZu8Wk_VuYaNCEGew'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/channel_http_test.py:440: AssertionError
_______________________ test_channel_messages_v1_simple ________________________

clear = None
user_token1 = {'auth_user_id': 71, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjcxLCJsb2dpbl90aW1lIjoxNjE5MTg4MTY5LCJzYWx0IjoiMDU2YTMzNWMtY2RmMy00MDFkLThmNDEtNDJjNmRmNzQ1MWZkIn0.EnqQsYJUHQuMrYe_sK3-c-ggxkYQY5AeOvQLPQ-Xm24'}
user_token2 = {'auth_user_id': 72, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjcyLCJsb2dpbl90aW1lIjoxNjE5MTg4MTY5LCJzYWx0IjoiNTdhYjkwYjktYjEwOS00NjNlLTlhMDMtYjliNGY5MjI5Yzk0In0.YWSEMFhRCNRIgXMzlWTWumXzBFLVCnOiRvgaoZ6dta4'}
public_channel = {'channel_id': 73}

    def test_channel_messages_v1_simple(clear, user_token1, user_token2, public_channel):
        channel_id = public_channel['channel_id']
        requests.post(f"{url}/message/send/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id,
            'message': "Hello"
        }).json()
        start = 0
        messages = requests.get(f"{url}/channel/messages/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id,
>           'start': start
        }).json()

http_tests/channel_http_test.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
________________________ test_channel_messages_v1_many _________________________

clear = None
user_token1 = {'auth_user_id': 75, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjc1LCJsb2dpbl90aW1lIjoxNjE5MTg4MTY5LCJzYWx0IjoiNGYyMGQ0YWQtZjQxNC00MjIwLWFjNWEtMmM4YWVjZWY1MTMwIn0.-Zc02NBG74Dxs-6ZNFRM34SoczVTcf17vZ_NuLqiFQA'}
user_token2 = {'auth_user_id': 76, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjc2LCJsb2dpbl90aW1lIjoxNjE5MTg4MTY5LCJzYWx0IjoiNDBkMDM4NTgtOGUyNS00YjViLTlhNWMtMTQ5MTAyNmY3YjFlIn0.RHI6TiRMEJP7dgHqbz41QqvPUbH6U1pTVLN63UlR7Zg'}
public_channel = {'channel_id': 77}

    def test_channel_messages_v1_many(clear, user_token1, user_token2, public_channel):
        channel_id = public_channel['channel_id']
        for i in range(0, 50):
            requests.post(f"{url}/message/send/v2", json={
                'token': user_token1['token'],
                'channel_id': channel_id,
                'message': f"message number {i}"
            }).json()
        start = 0
        messages = requests.get(f"{url}/channel/messages/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id,
>           'start': start
        }).json()

http_tests/channel_http_test.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_____________________ test_channel_messages_invalid_token ______________________

clear = None, channel_id1 = {'channel_id': 129}

    def test_channel_messages_invalid_token(clear, channel_id1):
>       assert requests.get(f"{url}/channel/messages/v2", json={
            'token': INVALID_TOKEN,
            'channel_id': channel_id1['channel_id'],
            'start': 0
        }).status_code == INPUT_ERROR
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//channel/messages/v2', json={'channel_id': 129, 'start': 0, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzZXNzaW9uX2lkIjo5OTk5fQ.DLVgZojClKM67VJkwqWJ9iyYG-qbWH1MHbGe0noFt-s'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/channel_http_test.py:478: AssertionError
______________________ test_channel_join_v1_empty_channel ______________________

clear = None
user_token1 = {'auth_user_id': 130, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjEzMCwibG9naW5fdGltZSI6MTYxOTE4ODE2OSwic2FsdCI6IjYxMTFhNWZmLWZkZDktNGVmMC1hNGI1LTRiOWMzOGJjYjcxOSJ9.eCs2rOW__wPW79kOW_NzYfnEjFRa3xO5PFIoVQfopaA'}
public_channel = {'channel_id': 131}

    def test_channel_join_v1_empty_channel(clear, user_token1, public_channel):
        """
        Test adding to empty channel
        """
        channel_id = public_channel['channel_id']
        requests.post(f"{url}/channel/join/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id
        })
        channel_dict = requests.get(f"{url}/channel/details/v2", json={
            'token': user_token1['token'],
>           'channel_id': channel_id
        }).json()

http_tests/channel_http_test.py:499: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________ test_channel_join_v1_check_details ______________________

clear = None
user_token1 = {'auth_user_id': 138, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjEzOCwibG9naW5fdGltZSI6MTYxOTE4ODE2OSwic2FsdCI6IjQzOWJhMzdlLTYzMDUtNGIyMC1iNjRkLWNmNTQxZjNiZjE0YiJ9.n_j4Upen658w23FF0z2KkZoRfhMhwZiMeBzoVOAGcR0'}
user_token2 = {'auth_user_id': 139, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjEzOSwibG9naW5fdGltZSI6MTYxOTE4ODE2OSwic2FsdCI6ImU3OGEzNjZkLWQyOWMtNGNjNy1hMTZlLTRhNzA3ZmI5YjhjOCJ9.D3Kv7A9WXcihsyCxV6uYl_eLGMw8SVn1cCRySEqlOzA'}
public_channel = {'channel_id': 140}

    def test_channel_join_v1_check_details(clear, user_token1, user_token2, public_channel):
        """
        Test if details are correctly added when adding more than one user
        """
        channel_id = public_channel['channel_id']
        requests.post(f"{url}/channel/join/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id
        })
        requests.post(f"{url}/channel/join/v2", json={
            'token': user_token2['token'],
            'channel_id': channel_id
        })
        channel_info = requests.get(f"{url}/channel/details/v2", json={
            'token': user_token1['token'],
>           'channel_id': channel_id
        }).json()

http_tests/channel_http_test.py:542: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_channel_join_invalid_token ________________________

clear = None, channel_id1 = {'channel_id': 142}

    def test_channel_join_invalid_token(clear, channel_id1):
>       assert requests.post(f"{url}/channel/join/v2", json={
            'token': INVALID_TOKEN,
            'channel_id': channel_id1['channel_id']
        }).status_code == INPUT_ERROR
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7f7f8f7e5e18>('http://127.0.0.1:6080//channel/join/v2', json={'channel_id': 142, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzZXNzaW9uX2lkIjo5OTk5fQ.DLVgZojClKM67VJkwqWJ9iyYG-qbWH1MHbGe0noFt-s'})
E        +      where <function post at 0x7f7f8f7e5e18> = requests.post

http_tests/channel_http_test.py:552: AssertionError
_________________________ test_channel_join_owner_perm _________________________

clear = None, channel_id1 = {'channel_id': 144}
user_token1 = {'auth_user_id': 143, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE0MywibG9naW5fdGltZSI6MTYxOTE4ODE2OSwic2FsdCI6ImNkZTcwZjg4LWE4MTYtNDM0Zi04ZmVmLTM0ODJkMzE1ODI0ZSJ9.9tVY-jqChddt2o3eD26xL4qBYAzQVScnrFFmyl95-34'}
user_token2 = {'auth_user_id': 145, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE0NSwibG9naW5fdGltZSI6MTYxOTE4ODE2OSwic2FsdCI6IjIyZGQyZGNmLTY1NTgtNDZmMS04YzFmLTE3ZmNkMGFhMTY5NiJ9.LqcvHx66_QkNVKBDxss2wS0zckeFROjeRoQXlHt5zwU'}

    def test_channel_join_owner_perm(clear, channel_id1, user_token1, user_token2):
        requests.post(f"{url}/channels/create/v2", json={
            'token': user_token2['token'],
            'name': "Channel",
            'is_public': False
        }).json()
        requests.post(f"{url}/channel/join/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id1['channel_id']
        })
        details = requests.get(f"{url}/channel/details/v2", json={
            'token': user_token1['token'],
>           'channel_id': channel_id1['channel_id']
        }).json()

http_tests/channel_http_test.py:569: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________ test_channel_addowner_v1_AddMulti _______________________

clear = None

    def test_channel_addowner_v1_AddMulti(clear):
        """
        Test whether multiple users will be added as owner of the channel properly
        in correct order
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
        requests.post(f"{url}/channel/addowner/v1", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info2['auth_user_id']
        })
        requests.post(f"{url}/channel/addowner/v1", json={
            'token': reg_info2['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info3['auth_user_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id']
        })
>       channel_details1 = channel_details1.json()

http_tests/channel_http_test.py:734: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_____________________ test_channel_addowner_invalid_token ______________________

clear = None

    def test_channel_addowner_invalid_token(clear):
        """
        Test invalid token for addowner
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
>       assert requests.post(f"{url}/channel/addowner/v1", json={
            'token': 'invalid_token',
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info1['auth_user_id']
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7f7f8f7e5e18>('http://127.0.0.1:6080//channel/addowner/v1', json={'channel_id': 161, 'token': 'invalid_token', 'u_id': 160})
E        +      where <function post at 0x7f7f8f7e5e18> = requests.post

http_tests/channel_http_test.py:755: AssertionError
___________________ test_channel_removeowner_v1_RemoveMulti ____________________

clear = None

    def test_channel_removeowner_v1_RemoveMulti(clear):
        """
        Test whether multiple users will be removed as owner of the channel properly
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
        requests.post(f"{url}/channel/addowner/v1", json={
            'token': reg_info1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info2['auth_user_id']
        })
        requests.post(f"{url}/channel/addowner/v1", json={
            'token': reg_info2['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info3['auth_user_id']
        })
        requests.post(f"{url}/channel/removeowner/v1", json={
            'token': reg_info3['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info2['auth_user_id']
        })
        requests.post(f"{url}/channel/removeowner/v1", json={
            'token': reg_info3['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info1['auth_user_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': reg_info3['token'],
            'channel_id': channel_id1['channel_id']
        })
>       channel_details1 = channel_details1.json()

http_tests/channel_http_test.py:960: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
____________________ test_channel_removeowner_invalid_token ____________________

clear = None

    def test_channel_removeowner_invalid_token(clear):
        """
        Test invalid token for removeowner
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        channel_id1 = requests.post(f"{url}/channels/create/v2", json={
            'token': reg_info1['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel_id1 = channel_id1.json()
>       assert requests.post(f"{url}/channel/removeowner/v1", json={
            'token': 'invalid_token',
            'channel_id': channel_id1['channel_id'],
            'u_id': reg_info1['auth_user_id']
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7f7f8f7e5e18>('http://127.0.0.1:6080//channel/removeowner/v1', json={'channel_id': 179, 'token': 'invalid_token', 'u_id': 178})
E        +      where <function post at 0x7f7f8f7e5e18> = requests.post

http_tests/channel_http_test.py:981: AssertionError
_________________________ test_channel_leave_v1_Leave1 _________________________

clear = None
user_token1 = {'auth_user_id': 184, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE4NCwibG9naW5fdGltZSI6MTYxOTE4ODE3MCwic2FsdCI6IjMyMzg0ZDc2LWViMjMtNDg5My04NTYyLWFhYjk1ZWZhM2QyNyJ9._AwRbrSswXrPSagU31qPu002M_lmOtIxsDRRmgXDdyw'}
channel_id1 = {'channel_id': 185}
user_token2 = {'auth_user_id': 186, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE4NiwibG9naW5fdGltZSI6MTYxOTE4ODE3MCwic2FsdCI6ImExYTE2NzZiLTRlMGYtNGEwMC04ODI5LWQzMTU4ZjNiZDI3NiJ9.KEV5NcUSldBSobGuCvziIT8hYH6gBMykv35Q3mwU8zc'}

    def test_channel_leave_v1_Leave1(clear, user_token1, channel_id1, user_token2):
        """
        Test whether a normal member can leave the channel properly
        """
        requests.post(f"{url}/channel/invite/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': user_token2['auth_user_id']
        })
        requests.post(f"{url}/channel/leave/v1", json={
            'token': user_token2['token'],
            'channel_id': channel_id1['channel_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': user_token1['token'],
>           'channel_id': channel_id1['channel_id']
        }).json()

http_tests/channel_http_test.py:1025: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_channel_leave_v1_LeaveMulti _______________________

clear = None
user_token1 = {'auth_user_id': 187, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE4NywibG9naW5fdGltZSI6MTYxOTE4ODE3MCwic2FsdCI6ImJkNWY2YTZmLWJlYmUtNDU0Yy04MTcyLTNhM2MyNDgxOWI1ZCJ9.qfPC52gfDG8GMRP6Xab87Es9Cnm6gYrmuDt7YiUqlDU'}
channel_id1 = {'channel_id': 188}
user_token2 = {'auth_user_id': 189, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE4OSwibG9naW5fdGltZSI6MTYxOTE4ODE3MCwic2FsdCI6IjYzOGRiNzVkLWI5ZDQtNGUxMC1hZTM0LWYwZTVhYTc1MWIxYiJ9.MXvLuPbKQCO0gJqlQDNa0n_NyBI4Myc4Yo0H38aZqgY'}
user_token3 = {'auth_user_id': 190, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE5MCwibG9naW5fdGltZSI6MTYxOTE4ODE3MCwic2FsdCI6ImM1ZWRlM2E1LTdiNWMtNDJkZi1hM2Y5LWRlNTdjNWMwNTJmZCJ9.cp4WcZVK_RiXkNc_L840YQrfnt2CR9TEOKVcMrDAXVo'}

    def test_channel_leave_v1_LeaveMulti(clear, user_token1, channel_id1, user_token2, user_token3):
        """
        Test whether multiple members can leave the channel properly
        """
        requests.post(f"{url}/channel/invite/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': user_token2['auth_user_id']
        })
        requests.post(f"{url}/channel/invite/v2", json={
            'token': user_token1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': user_token3['auth_user_id']
        })
        requests.post(f"{url}/channel/leave/v1", json={
            'token': user_token2['token'],
            'channel_id': channel_id1['channel_id']
        })
        requests.post(f"{url}/channel/leave/v1", json={
            'token': user_token3['token'],
            'channel_id': channel_id1['channel_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': user_token1['token'],
>           'channel_id': channel_id1['channel_id']
        }).json()

http_tests/channel_http_test.py:1054: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_channel_leave_v1_LeaveOwner _______________________

clear = None, channel_id1 = {'channel_id': 192}
user_token1 = {'auth_user_id': 191, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE5MSwibG9naW5fdGltZSI6MTYxOTE4ODE3MCwic2FsdCI6IjhlYTkwZGU0LWM3YTYtNGJmMy1hZGYzLTZkOTk5NTM1NDQwOSJ9.w6pC88dOSii0ZsWu7Zpk8aHhfhj3o4CQdORbhIlCqkw'}
user_token2 = {'auth_user_id': 193, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE5MywibG9naW5fdGltZSI6MTYxOTE4ODE3MCwic2FsdCI6IjllMGI5MjU1LWQ4NDUtNDE4MC05M2Y5LWMwMTI3MDYwMzZhYSJ9.qz_ZxD-u18M9N80i0BrORuCO3a8f0T24cbGf8aThduY'}

    def test_channel_leave_v1_LeaveOwner(clear, channel_id1, user_token1, user_token2):
        """
        Test whether a owner can leave the channel properly (not the last owner)
        They must be removed from all_members and owner_members
        """
        requests.post(f"{url}/channel/addowner/v1", json={
            'token': user_token1['token'],
            'channel_id': channel_id1['channel_id'],
            'u_id': user_token2['auth_user_id']
        })
        requests.post(f"{url}/channel/leave/v1", json={
            'token': user_token2['token'],
            'channel_id': channel_id1['channel_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': user_token1['token'],
>           'channel_id': channel_id1['channel_id']
        }).json()

http_tests/channel_http_test.py:1075: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_channel_leave_v1_last_owner _______________________

clear = None
user_token1 = {'auth_user_id': 194, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjE5NCwibG9naW5fdGltZSI6MTYxOTE4ODE3MCwic2FsdCI6IjlkZDM5MGVjLWJkMTYtNGEzZS1iYzVjLThhYzZiZDllNGRlMCJ9.AjWo4TnegZeCksEKV6yXSDVCa5cCgCGVQzofezyWnoQ'}
channel_id1 = {'channel_id': 195}

    def test_channel_leave_v1_last_owner(clear, user_token1, channel_id1):
        requests.post(f"{url}/channel/leave/v1", json={
            'token': user_token1['token'],
            'channel_id': channel_id1['channel_id']
        })
        channel_details1 = requests.get(f"{url}/channel/details/v2", json={
            'token': user_token1['token'],
>           'channel_id': channel_id1['channel_id']
        }).json()

http_tests/channel_http_test.py:1089: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_channel_leave_invalid_token _______________________

clear = None, channel_id1 = {'channel_id': 197}

    def test_channel_leave_invalid_token(clear, channel_id1):
>       assert requests.post(f"{url}/channel/leave/v1", json={
            'token': INVALID_TOKEN,
            'channel_id': channel_id1['channel_id']
        }).status_code == INPUT_ERROR
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7f7f8f7e5e18>('http://127.0.0.1:6080//channel/leave/v1', json={'channel_id': 197, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzZXNzaW9uX2lkIjo5OTk5fQ.DLVgZojClKM67VJkwqWJ9iyYG-qbWH1MHbGe0noFt-s'})
E        +      where <function post at 0x7f7f8f7e5e18> = requests.post

http_tests/channel_http_test.py:1094: AssertionError
_______________________________ test_empty_list ________________________________

clear = None

    def test_empty_list(clear):
        '''
        Tests for an empty list
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        channels = requests.get(f"{url}/channels/list/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
__________________________________ test_list ___________________________________

clear = None

    def test_list(clear):
        '''
        Basic test for functionality of channels/list/v2
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channels = requests.get(f"{url}/channels/list/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_____________________________ test_multiple_lists ______________________________

clear = None

    def test_multiple_lists(clear):
        '''
        Tests for multiple lists
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel2',
            'is_public': True
        })
        channels = requests.get(f"{url}/channels/list/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
__________________________ test_list_private_channel ___________________________

clear = None

    def test_list_private_channel(clear):
        '''
        Tests if private channels are listed properly
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': False
        })
        channels = requests.get(f"{url}/channels/list/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
________________________ test_channel_list_valid_token _________________________

clear = None

    def test_channel_list_valid_token(clear):
        '''
        Checks if token given is valid
        '''
        register_info = {
            'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZXNzaW9uX2lkIjo0fQ.UWh4yaDf6lPdmJroKBXfBZURXskoLULjM7Es_xZSK6U'
        }
>       assert requests.get(f"{url}/channels/list/v2", json={
            'token': register_info['token']
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//channels/list/v2', json={'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZXNzaW9uX2lkIjo0fQ.UWh4yaDf6lPdmJroKBXfBZURXskoLULjM7Es_xZSK6U'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/channels_http_test.py:99: AssertionError
______________________________ test_empty_listall ______________________________

clear = None

    def test_empty_listall(clear):
        '''
        Tests for an empty list
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        channels = requests.get(f"{url}/channels/listall/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_________________________________ test_listall _________________________________

clear = None

    def test_listall(clear):
        '''
        Basic test for channels/listall/v2
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channels = requests.get(f"{url}/channels/listall/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
____________________________ test_multiple_listall _____________________________

clear = None

    def test_multiple_listall(clear):
        '''
        Test multiple lists
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel2',
            'is_public': True
        })
        channels = requests.get(f"{url}/channels/listall/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_________________________ test_listall_private_channel _________________________

clear = None

    def test_listall_private_channel(clear):
        '''
        Tests if private channels appear in the list
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': False
        })
        channels = requests.get(f"{url}/channels/listall/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
___________________________ test_listall_valid_token ___________________________

clear = None

    def test_listall_valid_token(clear):
        '''
        Tests for an invalid token
        '''
        register_info = {
            'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZXNzaW9uX2lkIjo0fQ.UWh4yaDf6lPdmJroKBXfBZURXskoLULjM7Es_xZSK6U'
        }
>       assert requests.get(f"{url}/channels/listall/v2", json={
            'token': register_info['token']
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//channels/listall/v2', json={'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZXNzaW9uX2lkIjo0fQ.UWh4yaDf6lPdmJroKBXfBZURXskoLULjM7Es_xZSK6U'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/channels_http_test.py:187: AssertionError
_________________________________ test_create __________________________________

clear = None

    def test_create(clear):
        '''
        Basic test for functionality of channels/
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        }).json()
        requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channels = requests.get(f"{url}/channels/listall/v2", json={
>           'token': register_info['token']
        }).json()

http_tests/channels_http_test.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________ test_channels_create_invalid_token ______________________

clear = None

    def test_channels_create_invalid_token(clear):
        '''
        Tests for invalid token
        '''
        register_info = {
            'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZXNzaW9uX2lkIjo0fQ.UWh4yaDf6lPdmJroKBXfBZURXskoLULjM7Es_xZSK6U'
        }
>       assert requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7f7f8f7e5e18>('http://127.0.0.1:6080//channels/create/v2', json={'is_public': True, 'name': 'Channel1', 'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZXNzaW9uX2lkIjo0fQ.UWh4yaDf6lPdmJroKBXfBZURXskoLULjM7Es_xZSK6U'})
E        +      where <function post at 0x7f7f8f7e5e18> = requests.post

http_tests/channels_http_test.py:234: AssertionError
________________________ test_dm_details_v1_input_error ________________________

clear = None
user_token1 = {'auth_user_id': 218, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIxOCwibG9naW5fdGltZSI6MTYxOTE4ODE3MCwic2FsdCI6IjY3NzNmYTdmLWViZGItNDA2Zi1hYTg1LWQxMWJjNzI1MmU0MyJ9.w-2PQ4bZeo32tMxgOwvxFT1IEnD2zt4aUzXyvDBF0aw'}

    def test_dm_details_v1_input_error(clear, user_token1):
        """
        InputError to be thrown when DM ID is not a valid DM
        """
>       assert requests.get(f"{url}/dm/details/v1", json={
            'token': user_token1['token'],
            'dm_id': INVALID_ID
        }).status_code == INPUT_ERROR
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//dm/details/v1', json={'dm_id': 9999, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIxOCwibG9naW5fdGltZSI6MTYxOTE4ODE3MCwic2FsdCI6IjY3NzNmYTdmLWViZGItNDA2Zi1hYTg1LWQxMWJjNzI1MmU0MyJ9.w-2PQ4bZeo32tMxgOwvxFT1IEnD2zt4aUzXyvDBF0aw'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/dm_http_test.py:98: AssertionError
_______________________ test_dm_details_v1_access_error ________________________

clear = None
unadded_user_token = {'auth_user_id': 222, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIyMiwibG9naW5fdGltZSI6MTYxOTE4ODE3MSwic2FsdCI6ImFlYWFhYjM5LTU5YzQtNGViMi05MjI1LTM5MWM4MjQ1NmVhZCJ9.blVTe0gOzCBtpWd7tLxTyvs6per46aWH3NGEoAeo1FQ'}
dm_1 = {'dm_id': 223, 'dm_name': 'godanliang, jeremylee, rolandlin'}

    def test_dm_details_v1_access_error(clear, unadded_user_token, dm_1):
        """
        AccessError to be thrown when authorised user is not a member of this DM with dm_id
        """
>       assert requests.get(f"{url}/dm/details/v1", json={
            'token': unadded_user_token['token'],
            'dm_id': dm_1['dm_id']
        }).status_code == ACCESS_ERROR
E       AssertionError: assert 500 == 403
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//dm/details/v1', json={'dm_id': 223, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIyMiwibG9naW5fdGltZSI6MTYxOTE4ODE3MSwic2FsdCI6ImFlYWFhYjM5LTU5YzQtNGViMi05MjI1LTM5MWM4MjQ1NmVhZCJ9.blVTe0gOzCBtpWd7tLxTyvs6per46aWH3NGEoAeo1FQ'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/dm_http_test.py:107: AssertionError
__________________________ test_dm_details_v1_simple ___________________________

clear = None
user_token1 = {'auth_user_id': 224, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIyNCwibG9naW5fdGltZSI6MTYxOTE4ODE3MSwic2FsdCI6IjA1ZjE1YWUwLTc4MzYtNDhkYS05MGNlLWY5OTc5ZDY1ZWUxOSJ9.hOQxk0Al5NLlK9l7AdYSrHlsmn1DUVK5-ixRPGWpeoA'}
user_token2 = {'auth_user_id': 225, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIyNSwibG9naW5fdGltZSI6MTYxOTE4ODE3MSwic2FsdCI6ImM0ZDJiYzljLTQ4MTYtNDllMC1hZTRjLTg5YjlhOWU0ZTk1NiJ9.FNUTVb2caY4dFXR2GyeXMaPX1RPVlz162DTH_uKcInc'}
user_token3 = {'auth_user_id': 226, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIyNiwibG9naW5fdGltZSI6MTYxOTE4ODE3MSwic2FsdCI6IjlkMDY0NTQ5LTNmZTQtNDg0NC04YTg3LWVkNjYyNmRlODFmYyJ9.DZf4tgLhQ8tLx1k2V7K-2sVJOwAVdN-U7LVpHfS7cJk'}
dm_1 = {'dm_id': 227, 'dm_name': 'godanliang, jeremylee, rolandlin'}

    def test_dm_details_v1_simple(clear, user_token1, user_token2, user_token3, dm_1):
        """
        Testing whether dm_details_v1 returns the correct name and members
        """
        dm_details = requests.get(f"{url}/dm/details/v1", json={
            'token': user_token1['token'],
>           'dm_id': dm_1['dm_id']
        }).json()

http_tests/dm_http_test.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
____________________________ test_dm_list_v1_simple ____________________________

clear = None
user_token1 = {'auth_user_id': 228, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIyOCwibG9naW5fdGltZSI6MTYxOTE4ODE3MSwic2FsdCI6ImViZmE0YTJmLWJlMzctNDk5Ny04OWIzLWJlNjE4NDc0YzRjNCJ9.KCnxz2gOnrO2qpave1dMRv5u_aSE5ihKMOllTXx0QgU'}
dm_1 = {'dm_id': 231, 'dm_name': 'godanliang, jeremylee, rolandlin'}
dm_2 = {'dm_id': 232, 'dm_name': 'godanliang, jeremylee'}

    def test_dm_list_v1_simple(clear, user_token1, dm_1, dm_2):
        """
        Testing whether dm_list_v1 returns the list of DMs correctly
        """
        dms = requests.get(f"{url}/dm/list/v1", json={
>           'token': user_token1['token']
        }).json()

http_tests/dm_http_test.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
___________________________ test_dm_create_v1_simple ___________________________

clear = None
user_token1 = {'auth_user_id': 234, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIzNCwibG9naW5fdGltZSI6MTYxOTE4ODE3MSwic2FsdCI6IjZiNDI4N2E2LTdkMzktNDZjMC04OTBjLTgxNTU5Y2IxNWY1MyJ9.q7apx_xpGCchOdkHpSbI_eIcWKXny-MUMCYlceCMGBI'}
user_token2 = {'auth_user_id': 235, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIzNSwibG9naW5fdGltZSI6MTYxOTE4ODE3MSwic2FsdCI6IjZhMjA1N2U0LWVlMzktNDU3Ni1iNzhlLWM2NzdkNzY0NjM3MiJ9.0NsFVKHhuMtqlW5qAphNsyqnLLqHl6XwaOF5llOPt2w'}
user_token3 = {'auth_user_id': 236, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIzNiwibG9naW5fdGltZSI6MTYxOTE4ODE3MSwic2FsdCI6IjFmODg3Y2NiLTBhZTktNGE3MC04YjVmLTcyMzI3MWU5NmY0YiJ9.aY8C_I5M5KmZ3DxVZIClY0oy5yVy3DMJ_8DDPaA_5D4'}

    def test_dm_create_v1_simple(clear, user_token1, user_token2, user_token3):
        """
        Testing whether dm_create_v1 returns the correct dm_id and dm_name
        """
        u_ids = [user_token2['auth_user_id'], user_token3['auth_user_id']]
        dm_1 = requests.post(f"{url}/dm/create/v1", json={
            'token': user_token1['token'],
            'u_ids': u_ids
        }).json()
>       assert dm_1['dm_id'] == 0
E       assert 237 == 0

http_tests/dm_http_test.py:190: AssertionError
______________________________ test_dm_remove_v1 _______________________________

clear = None
user_token1 = {'auth_user_id': 244, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjI0NCwibG9naW5fdGltZSI6MTYxOTE4ODE3MSwic2FsdCI6IjE3MzJjOTE2LTUxMDgtNDc2Yi05N2NlLWUxNWMwMzdiN2VkOCJ9.rVk2VOABTEdU1sd5-BaI0-Ug3qI-42K_UK6NcoiucL0'}
dm_1 = {'dm_id': 247, 'dm_name': 'godanliang, jeremylee, rolandlin'}

    def test_dm_remove_v1(clear, user_token1, dm_1):
        """
        Testing whether dm is removed. If dm is removed, dm_details_v1 should raise
        InputError since dm is removed.
        """
        requests.delete(f"{url}/dm/remove/v1", json={
            'token': user_token1['token'],
            'dm_id': dm_1['dm_id']
        })
>       assert requests.get(f"{url}/dm/details/v1", json={
            'token': user_token1['token'],
            'dm_id': dm_1['dm_id']
        }).status_code == INPUT_ERROR
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//dm/details/v1', json={'dm_id': 247, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjI0NCwibG9naW5fdGltZSI6MTYxOTE4ODE3MSwic2FsdCI6IjE3MzJjOTE2LTUxMDgtNDc2Yi05N2NlLWUxNWMwMzdiN2VkOCJ9.rVk2VOABTEdU1sd5-BaI0-Ug3qI-42K_UK6NcoiucL0'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/dm_http_test.py:239: AssertionError
__________________________ test_dm_invite_v1_Invite1 ___________________________

clear = None

    def test_dm_invite_v1_Invite1(clear):
        """
        Test whether user will be invited and added to the specified DM
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        requests.post(f"{url}/dm/invite/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'u_id': reg_info3['auth_user_id']
        })
        dm_details = requests.get(f"{url}/dm/details/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id']
        })
>       dm_details = dm_details.json()

http_tests/dm_http_test.py:431: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
__________________________ test_dm_invite_v1_Invite2 ___________________________

clear = None

    def test_dm_invite_v1_Invite2(clear):
        """
        Test whether two users can be invited and added to the specified DM properly
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        reg_info4 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Bolin@gmail.com',
            'password': 'password',
            'name_first': 'Bolin',
            'name_last': 'Ngo'
        })
        reg_info4 = reg_info4.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        requests.post(f"{url}/dm/invite/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'u_id': reg_info3['auth_user_id']
        })
        requests.post(f"{url}/dm/invite/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'u_id': reg_info4['auth_user_id']
        })
        dm_details = requests.get(f"{url}/dm/details/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id']
        })
>       dm_details = dm_details.json()

http_tests/dm_http_test.py:485: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
___________________________ test_dm_leave_v1_Leave1 ____________________________

clear = None

    def test_dm_leave_v1_Leave1(clear):
        """
        Test whether a user can leave the specified DM properly and changes are made
        If the most recent user has left properly, the -1 index of members will be of the previous user
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        requests.post(f"{url}/dm/invite/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'u_id': reg_info3['auth_user_id']
        })
        requests.post(f"{url}/dm/leave/v1", json={
            'token': reg_info3['token'],
            'dm_id': dm_2['dm_id']
        })
        dm_details = requests.get(f"{url}/dm/details/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id']
        })
>       dm_details = dm_details.json()

http_tests/dm_http_test.py:588: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
__________________________ test_dm_leave_v1_LeaveALL ___________________________

clear = None

    def test_dm_leave_v1_LeaveALL(clear):
        """
        Test whether multiple users can leave the specified DM properly
        If all members of the DM leave, the members list for that DM should be empty
        Therefore, calling dm_details_v1 for anyone should raise an AccessError as the user is no longer part of the DM
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        requests.post(f"{url}/dm/invite/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'u_id': reg_info3['auth_user_id']
        })
        requests.post(f"{url}/dm/leave/v1", json={
            'token': reg_info3['token'],
            'dm_id': dm_2['dm_id']
        })
        requests.post(f"{url}/dm/leave/v1", json={
            'token': reg_info2['token'],
            'dm_id': dm_2['dm_id']
        })
        requests.post(f"{url}/dm/leave/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id']
        })
>       assert requests.get(f"{url}/dm/details/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id']
        }).status_code == 403
E       AssertionError: assert 500 == 403
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//dm/details/v1', json={'dm_id': 284, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjI4MSwibG9naW5fdGltZSI6MTYxOTE4ODE3MSwic2FsdCI6IjZhZWQ2ZjMzLTU1NTAtNDNjYi1hOGE5LWU1ZGNlY2UyZTU2OSJ9.clO2f7FeJAR4YAE8RLZYIKkvbcYO5x1XaLnHWG1PngI'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/dm_http_test.py:640: AssertionError
_______________________ test_dm_messages_v1_InputError1 ________________________

clear = None

    def test_dm_messages_v1_InputError1(clear):
        """
        InputError happens when dm_id does not refer to a existing DM
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
>       assert requests.get(f"{url}/dm/messages/v1", json={
            'token': reg_info1['token'],
            'dm_id': INVALID_ID,
            'start': 0
        }).status_code == 400
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//dm/messages/v1', json={'dm_id': 9999, 'start': 0, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjI4NSwibG9naW5fdGltZSI6MTYxOTE4ODE3MSwic2FsdCI6ImQ5NGFlN2NkLWU3NGMtNDY2Mi1iMjE5LTk2MzAwNWY3ZDdlZSJ9.NCHQroT9Q5AZKrCquEpPsNSJaz2uUuQAj5txlFcmo3Q'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/dm_http_test.py:668: AssertionError
_______________________ test_dm_messages_v1_InputError2 ________________________

clear = None

    def test_dm_messages_v1_InputError2(clear):
        """
        InputError happens when start is greater than total number of messages in
        the channel
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        message_id = requests.post(f"{url}/message/senddm/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'message': 'hi'
        })
        message_id = message_id.json()
>       assert requests.get(f"{url}/dm/messages/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'start': 1
        }).status_code == 400
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//dm/messages/v1', json={'dm_id': 288, 'start': 1, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjI4NiwibG9naW5fdGltZSI6MTYxOTE4ODE3MSwic2FsdCI6Ijg5ZmNmNmFjLWU0ZjEtNDRlZC1iZGM5LTA4YmRmYzA5ZmQwNSJ9.fkNtgCjwLC4Q2LX87VWYfXHBQiOT7Amg6dxVTS3gCNc'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/dm_http_test.py:704: AssertionError
_______________________ test_dm_messages_v1_AccessError ________________________

clear = None

    def test_dm_messages_v1_AccessError(clear):
        """
        AccessError happens when authorised user is not a member of the DM
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        reg_info3 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Roland@gmail.com',
            'password': 'password',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        reg_info3 = reg_info3.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        message_id = requests.post(f"{url}/message/senddm/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'message': 'hi'
        })
        message_id = message_id.json()
>       assert requests.get(f"{url}/dm/messages/v1", json={
            'token': reg_info3['token'],
            'dm_id': dm_2['dm_id'],
            'start': 0
        }).status_code == 403
E       AssertionError: assert 500 == 403
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//dm/messages/v1', json={'dm_id': 293, 'start': 0, 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjI5MiwibG9naW5fdGltZSI6MTYxOTE4ODE3MSwic2FsdCI6ImMzMzZlYWU3LTRjMGItNGIyNi1hOGY2LTkzM2Y5NWVjZmZjMSJ9.QztzXxfTjaqTkZsNglaTCw6fDoAoyKZ-SKQhGxSQ7cI'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get

http_tests/dm_http_test.py:746: AssertionError
__________________________ test_dm_messages_v1_simple __________________________

clear = None

    def test_dm_messages_v1_simple(clear):
        """
        Test if -1 is returned if start + 50 surpasses total messages
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        message_id = requests.post(f"{url}/message/senddm/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'message': 'hi'
        })
        message_id = message_id.json()
        messages = requests.get(f"{url}/dm/messages/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/dm_http_test.py:786: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________ test_dm_messages_v1_many_messages _______________________

clear = None

    def test_dm_messages_v1_many_messages(clear):
        """
        Test that all messages are returned if start + 50 is within total
        messages in DM
        """
        reg_info1 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Godan@gmail.com',
            'password': 'password',
            'name_first': 'Godan',
            'name_last': 'Liang'
        })
        reg_info1 = reg_info1.json()
        reg_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'Jeremy@gmail.com',
            'password': 'password',
            'name_first': 'Jeremy',
            'name_last': 'Lee'
        })
        reg_info2 = reg_info2.json()
        dm_2 = requests.post(f"{url}/dm/create/v1", json={
            'token': reg_info1['token'],
            'u_ids': [reg_info2['auth_user_id']]
        })
        dm_2 = dm_2.json()
        for i in range(0, 50):
            message_id = requests.post(f"{url}/message/senddm/v1", json={
                'token': reg_info1['token'],
                'dm_id': dm_2['dm_id'],
                'message': f"message number {i}"
            })
            message_id = message_id.json()
        messages = requests.get(f"{url}/dm/messages/v1", json={
            'token': reg_info1['token'],
            'dm_id': dm_2['dm_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/dm_http_test.py:826: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
__________________________________ test_echo ___________________________________

    def test_echo():
        '''
        A simple test to check echo
        '''
        resp = requests.get(config.url + 'echo', params={'data': 'hello'})
>       assert json.loads(resp.text) == {'data': 'hello'}

http_tests/echo_http_test.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f7f904df390>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________________ test_message_send _______________________________

clear = None

    def test_message_send(clear):
        '''
        Basic test for functionality of message/send/v2
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
        requests.post(f"{url}/message/send/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'message': 'Hello'
        })
        messages = requests.get(f"{url}/channel/messages/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/message_http_test.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
________________________ test_message_send_input_error2 ________________________

clear = None

    def test_message_send_input_error2(clear):
        '''
        Tests for when no message is put in
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
>       assert requests.post(f"{url}/message/send/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'message': ''
        }).status_code == 400
E       AssertionError: assert 200 == 400
E        +  where 200 = <Response [200]>.status_code
E        +    where <Response [200]> = <function post at 0x7f7f8f7e5e18>('http://127.0.0.1:6080//message/send/v2', json={'channel_id': 358, 'message': '', 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM1NywibG9naW5fdGltZSI6MTYxOTE4ODE3Miwic2FsdCI6IjFhZjJjNTI3LWE5MjItNDcyNS1iOTQ0LTVlOTg2NzQ4Y2FlOCJ9.526A4ucJgWI9ueou3tMheA0RxVP_sHTx_IEYLOJPIoc'})
E        +      where <function post at 0x7f7f8f7e5e18> = requests.post

http_tests/message_http_test.py:83: AssertionError
_______________________ test_message_send_invalid_token ________________________

clear = None

    def test_message_send_invalid_token(clear):
        '''
        Tests for invalid token
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
>       assert requests.post(f"{url}/message/send/v2", json={
            'token': 4,
            'channel_id': channel['channel_id'],
            'message': 'Hello'
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7f7f8f7e5e18>('http://127.0.0.1:6080//message/send/v2', json={'channel_id': 364, 'message': 'Hello', 'token': 4})
E        +      where <function post at 0x7f7f8f7e5e18> = requests.post

http_tests/message_http_test.py:134: AssertionError
______________________________ test_message_edit _______________________________

clear = None

    def test_message_edit(clear):
        '''
        Basic test for functionality of message/edit/v2
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
        message_id = requests.post(f"{url}/message/send/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'message': 'Hello'
        })
        message_id = message_id.json()
        print(message_id)
        requests.put(f"{url}/message/edit/v2", json={
            'token': register_info['token'],
            'message_id': message_id['message_id'],
            'message': '123'
        })
        messages = requests.get(f"{url}/channel/messages/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/message_http_test.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
----------------------------- Captured stdout call -----------------------------
{'message_id': 367}
__________________________ test_edit_message_no_error __________________________

clear = None

    def test_edit_message_no_error(clear):
        '''
        Checks to see if regular member can edit their message
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        register_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'roland@gmail.com',
            'password': '12345678',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        register_info2 = register_info2.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
        requests.post(f"{url}/channel/join/v2", json={
            'token': register_info2['token'],
            'channel_id': channel['channel_id']
        })
        message_id = requests.post(f"{url}/message/send/v2", json={
            'token': register_info2['token'],
            'channel_id': channel['channel_id'],
            'message': 'Hello'
        })
        message_id = message_id.json()
        requests.put(f"{url}/message/edit/v2", json={
            'token': register_info2['token'],
            'message_id': message_id['message_id'],
            'message': '123'
        })
        messages = requests.get(f"{url}/channel/messages/v2", json={
            'token': register_info2['token'],
            'channel_id': channel['channel_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/message_http_test.py:319: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_____________________________ test_message_remove ______________________________

clear = None

    def test_message_remove(clear):
        '''
        Basic test for message/remove/v2
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
        message_id = requests.post(f"{url}/message/send/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'message': 'Hello'
        })
        message_id = message_id.json()
        requests.delete(f"{url}/message/remove/v1", json={
            'token': register_info['token'],
            'message_id': message_id['message_id']
        })
        messages = requests.get(f"{url}/channel/messages/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/message_http_test.py:354: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
____________________________ test_message_remove_dm ____________________________

clear = None

    def test_message_remove_dm(clear):
        '''
        Tests removing a message from a dm
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        register_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'roland@gmail.com',
            'password': '12345678',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        register_info2 = register_info2.json()
        dm_info = requests.post(f"{url}/dm/create/v1", json={
            'token': register_info['token'],
            'u_ids': [register_info2['auth_user_id']]
        })
        dm_info = dm_info.json()
        message_info = requests.post(f"{url}/message/senddm/v1", json={
            'token': register_info['token'],
            'dm_id': dm_info['dm_id'],
            'message': 'Hello'
        })
        message_info = message_info.json()
        requests.delete(f"{url}/message/remove/v1", json={
            'token': register_info['token'],
            'message_id': message_info['message_id'],
        })
        messages = requests.get(f"{url}/dm/messages/v1", json={
            'token': register_info['token'],
            'dm_id': dm_info['dm_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/message_http_test.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________________ test_message_share ______________________________

clear = None

    def test_message_share(clear):
        '''
        Basic testfor message/share/v2
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
        channel2 = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel2',
            'is_public': True
        })
        channel2 = channel2.json()
        message_info = requests.post(f"{url}/message/send/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'message': 'Hello'
        })
        message_info = message_info.json()
        requests.post(f"{url}/message/share/v1", json={
            'token': register_info['token'],
            'og_message_id': message_info['message_id'],
            'message': '123',
            'channel_id': channel2['channel_id'],
            'dm_id': -1
        })
        messages = requests.get(f"{url}/channel/messages/v2", json={
            'token': register_info['token'],
            'channel_id': channel2['channel_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/message_http_test.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_message_share_invalid_token _______________________

clear = None

    def test_message_share_invalid_token(clear):
        '''
        Tests for invalid token
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        channel = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel1',
            'is_public': True
        })
        channel = channel.json()
        channel2 = requests.post(f"{url}/channels/create/v2", json={
            'token': register_info['token'],
            'name': 'Channel2',
            'is_public': True
        })
        channel2 = channel2.json()
        message_info = requests.post(f"{url}/message/send/v2", json={
            'token': register_info['token'],
            'channel_id': channel['channel_id'],
            'message': 'Hello'
        })
        message_info = message_info.json()
>       assert requests.post(f"{url}/message/share/v1", json={
            'token': 1,
            'og_message_id': message_info['message_id'],
            'message': '123',
            'channel_id': channel2['channel_id'],
            'dm_id': -1
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7f7f8f7e5e18>('http://127.0.0.1:6080//message/share/v1', json={'channel_id': 408, 'dm_id': -1, 'message': '123', 'og_message_id': 409, ...})
E        +      where <function post at 0x7f7f8f7e5e18> = requests.post

http_tests/message_http_test.py:581: AssertionError
_____________________________ test_message_senddm ______________________________

clear = None

    def test_message_senddm(clear):
        '''
        Basic test for functionality of message/senddm/v2
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        register_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'roland@gmail.com',
            'password': '12345678',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        register_info2 = register_info2.json()
        dm_info = requests.post(f"{url}/dm/create/v1", json={
            'token': register_info['token'],
            'u_ids': [register_info2['auth_user_id']]
        })
        dm_info = dm_info.json()
        requests.post(f"{url}/message/senddm/v1", json={
            'token': register_info['token'],
            'dm_id': dm_info['dm_id'],
            'message': 'Hello'
        })
        messages = requests.get(f"{url}/dm/messages/v1", json={
            'token': register_info['token'],
            'dm_id': dm_info['dm_id'],
            'start': 0
        })
>       messages = messages.json()

http_tests/message_http_test.py:662: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________ test_message_senddm_invalid_token _______________________

clear = None

    def test_message_senddm_invalid_token(clear):
        '''
        Tests for invalid token
        '''
        register_info = requests.post(f"{url}/auth/register/v2", json={
            'email': 'gordon@gmail.com',
            'password': '12345678',
            'name_first': 'Gordon',
            'name_last': 'Liang'
        })
        register_info = register_info.json()
        register_info2 = requests.post(f"{url}/auth/register/v2", json={
            'email': 'roland@gmail.com',
            'password': '12345678',
            'name_first': 'Roland',
            'name_last': 'Lin'
        })
        register_info2 = register_info2.json()
        dm_info = requests.post(f"{url}/dm/create/v1", json={
            'token': register_info['token'],
            'u_ids': [register_info2['auth_user_id']]
        })
        dm_info = dm_info.json()
>       assert requests.post(f"{url}/message/senddm/v1", json={
            'token': 1,
            'dm_id': dm_info['dm_id'],
            'message': 'Hello'
        }).status_code == 400
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function post at 0x7f7f8f7e5e18>('http://127.0.0.1:6080//message/senddm/v1', json={'dm_id': 423, 'message': 'Hello', 'token': 1})
E        +      where <function post at 0x7f7f8f7e5e18> = requests.post

http_tests/message_http_test.py:750: AssertionError
________________________________ test_search_v2 ________________________________

clear_data = None

    def test_search_v2(clear_data):
        '''
        Basic test for functionality of search function
        '''
        user = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'skadi@gmail.com',
            'password': '1234aaaaaa',
            'name_first': 'Tom',
            'name_last': 'Diaaa',
        })
        user_pl = user.json()
    
        channel_info = requests.post(config.url + 'channels/create/v2', json = {
            'token': user_pl['token'],
            'name': 'Channel1',
            'is_public': True,
        })
        channel_info_pl = channel_info.json()
    
        requests.post(config.url + 'message/send/v2', json = {
            'token': user_pl['token'],
            'channel_id': channel_info_pl['channel_id'],
            'message': 'Hello',
        })
    
>       assert requests.get(config.url + 'search/v2', json = {
            'token': user_pl['token'],
            'query_str': 'Hello',
        }).status_code == 200
E       AssertionError: assert 403 == 200
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function get at 0x7f7f8f7e5c80>(('http://127.0.0.1:6080/' + 'search/v2'), json={'query_str': 'Hello', 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQyNCwibG9naW5fdGltZSI6MTYxOTE4ODE3Mywic2FsdCI6ImRjN2RkYjliLTEzNWMtNGZjNC1iYWE0LWRmYmMxMzZkOGJlMSJ9.vOmvlex8_rq0HTX3dHSLHRTtWxhQUsBqB6awM9ICIig'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get
E        +      and   'http://127.0.0.1:6080/' = config.url

http_tests/other_http_test.py:47: AssertionError
__________________________ test_search_v2_input_error __________________________

clear_data = None

    def test_search_v2_input_error(clear_data):
        '''
        Test for invalid query_str in search function
        '''
        user = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'skadi@gmail.com',
            'password': '1234aaaaaa',
            'name_first': 'Sing',
            'name_last': 'Diaaa',
        })
        user_pl = user.json()
    
        channel_info = requests.post(config.url + 'channels/create/v2', json = {
            'token': user_pl['token'],
            'name': 'Channel1',
            'is_public': True,
        })
        channel_info_pl = channel_info.json()
    
        requests.post(config.url + 'message/send/v2', json = {
            'token': user_pl['token'],
            'channel_id': channel_info_pl['channel_id'],
            'message': 'Hello',
        })
    
>       assert requests.get(config.url + 'search/v2', json = {
            'token': user_pl['token'],
            'query_str':'Hello' * 1000,
        }).status_code == InputError.code
E       AssertionError: assert 403 == 400
E        +  where 403 = <Response [403]>.status_code
E        +    where <Response [403]> = <function get at 0x7f7f8f7e5c80>(('http://127.0.0.1:6080/' + 'search/v2'), json={'query_str': 'HelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHel...xOTE4ODE3Mywic2FsdCI6ImE4NWU0YzJjLWU5ODItNDEyMy05MmVjLTVhYWY1YThmODQ1ZCJ9.ZAJ4eOxZmAdJHQAKrD541alhDMt42lqMZe2gKq1IAao'})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get
E        +      and   'http://127.0.0.1:6080/' = config.url
E        +  and   400 = InputError.code

http_tests/other_http_test.py:77: AssertionError
__________________________ test_notifications_get_tag __________________________

clear_data = None

    def test_notifications_get_tag(clear_data):
        '''
        Test if user got tagged in channel
        '''
        user = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'gordon@gmail.com',
            'password': '1234aaaaaa',
            'name_first': 'Gordon',
            'name_last': 'Liang',
        })
        user_pl = user.json()
    
        channel_info = requests.post(config.url + 'channels/create/v2', json = {
            'token': user_pl['token'],
            'name': 'Channel1',
            'is_public': True,
        })
        channel_info_pl = channel_info.json()
    
        requests.post(config.url + 'message/send/v2', json = {
            'token': user_pl['token'],
            'channel_id': channel_info_pl['channel_id'],
            'message': 'Hello @gordonliang',
        })
    
        notification = requests.get(config.url + 'notifications/get/v1', json = {
            'token': user_pl['token'],
        })
>       notification_pl = notification.json()

http_tests/other_http_test.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
____________________ test_notifications_get_add_to_channel _____________________

clear_data = None

    def test_notifications_get_add_to_channel(clear_data):
        '''
        Test if user got added in channel
        '''
        user = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'gordon@gmail.com',
            'password': '1234aaaaaa',
            'name_first': 'Gordon',
            'name_last': 'Liang',
        })
        user_pl = user.json()
    
        user2 = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'kanit@gmail.com',
            'password': '12345678',
            'name_first': 'Kanit',
            'name_last': 'Srihakorth',
        })
        user2_pl = user2.json()
    
        channel_info = requests.post(config.url + 'channels/create/v2', json = {
            'token': user_pl['token'],
            'name': 'Channel1',
            'is_public': True,
        })
        channel_info_pl = channel_info.json()
    
        requests.post(config.url + 'channel/invite/v2', json = {
            'token': user_pl['token'],
            'channel_id': channel_info_pl['channel_id'],
            'u_id': user2_pl['auth_user_id'],
        })
    
        notification = requests.get(config.url + 'notifications/get/v1', json = {
            'token': user2_pl['token'],
        })
>       notification_pl = notification.json()

http_tests/other_http_test.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
________________________ test_notifications_get_tag_dm _________________________

clear_data = None

    def test_notifications_get_tag_dm(clear_data):
        '''
        Test if user got tagged in dm
        '''
        user = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'gordon@gmail.com',
            'password': '1234aaaaaa',
            'name_first': 'Gordon',
            'name_last': 'Liang',
        })
        user_pl = user.json()
    
        user2 = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'kanit@gmail.com',
            'password': '12345678',
            'name_first': 'Kanit',
            'name_last': 'Srihakorth',
        })
        user2_pl = user2.json()
    
        dm_info = requests.post(config.url + 'dm/create/v1', json = {
            'token': user_pl['token'],
            'u_ids': [user2_pl['auth_user_id']],
        })
        dm_info_pl = dm_info.json()
    
        requests.post(config.url + 'message/senddm/v1', json = {
            'token': user_pl['token'],
            'dm_id': dm_info_pl['dm_id'],
            'message': 'Hello @kanitsrihakorth',
        })
    
        notification = requests.get(config.url + 'notifications/get/v1', json = {
            'token': user2_pl['token'],
        })
>       notification_pl = notification.json()

http_tests/other_http_test.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_notifications_get_add_to_dm _______________________

clear_data = None

    def test_notifications_get_add_to_dm(clear_data):
        '''
        Test if user got added in dm
        '''
        user = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'gordon@gmail.com',
            'password': '1234aaaaaa',
            'name_first': 'Gordon',
            'name_last': 'Liang',
        })
        user_pl = user.json()
    
        user2 = requests.post(config.url + 'auth/register/v2', json = {
            'email': 'kanit@gmail.com',
            'password': '12345678',
            'name_first': 'Kanit',
            'name_last': 'Srihakorth',
        })
        user2_pl = user2.json()
    
        requests.post(config.url + 'dm/create/v1', json = {
            'token': user_pl['token'],
            'u_ids': [user2_pl['auth_user_id']],
        })
    
        notification = requests.get(config.url + 'notifications/get/v1', json = {
            'token': user2_pl['token'],
        })
>       notification_pl = notification.json()

http_tests/other_http_test.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7f8fb94588>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7f9034d9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________________ test_invalid_uid _______________________________

clear_data = None

    def test_invalid_uid(clear_data):
        r = requests.post(f'{url}/auth/register/v2', json={
            'email': 'tom@gmail.com',
            'password': 'hello1234',
            'name_first': 'tom',
            'name_last': 'brown',
        })
        payload = r.json()
>       assert requests.get(f'{url}/user/profile/v2', json={
            'token': payload['token'],
            'u_id': 10000
        }).status_code == InputError.code
E       AssertionError: assert 500 == 400
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//user/profile/v2', json={'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQ0MywibG9naW5fdGltZSI6MTYxOTE4ODE3Mywic2FsdCI6ImJjMGFhNTkwLTMzYzEtNGExYS05NWNkLWRkNTlmZWVmOWE4NSJ9.6A9sYQjWqmJKEFf-fCk2FHDHlUgv2cSmIg3i9UB4Paw', 'u_id': 10000})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get
E        +  and   400 = InputError.code

http_tests/user_http_test.py:29: AssertionError
__________________________ test_invalid_token_profile __________________________

clear_data = None

    def test_invalid_token_profile(clear_data):
        user = requests.post(f'{url}/auth/register/v2', json={
            'email': 'tom@gmail.com',
            'password': 'hello1234',
            'name_first': 'tom',
            'name_last': 'brown',
        }).json()
    
>       assert requests.get(f'{url}/user/profile/v2', json={
            'token': 'invalid_token',
            'u_id': user['auth_user_id']
        }).status_code == AccessError.code
E       AssertionError: assert 500 == 403
E        +  where 500 = <Response [500]>.status_code
E        +    where <Response [500]> = <function get at 0x7f7f8f7e5c80>('http://127.0.0.1:6080//user/profile/v2', json={'token': 'invalid_token', 'u_id': 444})
E        +      where <function get at 0x7f7f8f7e5c80> = requests.get
E        +  and   403 = AccessError.code

http_tests/user_http_test.py:43: AssertionError
________________________________ test_all_users ________________________________

clear_data = None

    def test_all_users(clear_data):
        r = requests.post(f'{url}/auth/register/v2', json={
            'email': 'tom@gmail.com',
            'password': 'hello1234',
            'name_first': 'tom',
            'name_last': 'brown',
        })
        payload = r.json()
        requests.post(f'{url}/auth/register/v2', json={
            'email': 'rob@gmail.com',
            'password': 'hello1234',
            'name_first': 'rob',
            'name_last': 'blue',
        })
        query_string = f"token={payload['token']}"
        users = requests.get(f'{url}/users/all/v1?{query_string}')
        payload2 = users.json()
>       assert len(payload2) == 2
E       AssertionError: assert 1 == 2
E        +  where 1 = len({'users': [{'email': 'tom@gmail.com', 'handle_str': 'tombrown', 'name_first': 'tom', 'name_last': 'brown', ...}, {'email': 'rob@gmail.com', 'handle_str': 'robblue', 'name_first': 'rob', 'name_last': 'blue', ...}]})

http_tests/user_http_test.py:209: AssertionError
=========================== short test summary info ============================
FAILED http_tests/admin_http_test.py::test_invalid_permissin_id_admin_userpermission_change_v1
FAILED http_tests/admin_http_test.py::test_invalid_permissin_id_admin_userpermission_change_v1
FAILED http_tests/channel_http_test.py::test_channel_invite_v1_AccessErr - As...
FAILED http_tests/channel_http_test.py::test_channel_invite_v1_AddMulti - sim...
FAILED http_tests/channel_http_test.py::test_channel_invite_invalid_token - A...
FAILED http_tests/channel_http_test.py::test_channel_details_v1_InputErr - As...
FAILED http_tests/channel_http_test.py::test_channel_details_v1_AccessErr - A...
FAILED http_tests/channel_http_test.py::test_channel_details_v1_OneInv - simp...
FAILED http_tests/channel_http_test.py::test_channel_details_invalid_token - ...
FAILED http_tests/channel_http_test.py::test_channel_messages_v1_input_error1
FAILED http_tests/channel_http_test.py::test_channel_messages_v1_input_error2
FAILED http_tests/channel_http_test.py::test_channel_messages_v1_access_error
FAILED http_tests/channel_http_test.py::test_channel_messages_v1_simple - sim...
FAILED http_tests/channel_http_test.py::test_channel_messages_v1_many - simpl...
FAILED http_tests/channel_http_test.py::test_channel_messages_invalid_token
FAILED http_tests/channel_http_test.py::test_channel_join_v1_empty_channel - ...
FAILED http_tests/channel_http_test.py::test_channel_join_v1_check_details - ...
FAILED http_tests/channel_http_test.py::test_channel_join_invalid_token - Ass...
FAILED http_tests/channel_http_test.py::test_channel_join_owner_perm - simple...
FAILED http_tests/channel_http_test.py::test_channel_addowner_v1_AddMulti - s...
FAILED http_tests/channel_http_test.py::test_channel_addowner_invalid_token
FAILED http_tests/channel_http_test.py::test_channel_removeowner_v1_RemoveMulti
FAILED http_tests/channel_http_test.py::test_channel_removeowner_invalid_token
FAILED http_tests/channel_http_test.py::test_channel_leave_v1_Leave1 - simple...
FAILED http_tests/channel_http_test.py::test_channel_leave_v1_LeaveMulti - si...
FAILED http_tests/channel_http_test.py::test_channel_leave_v1_LeaveOwner - si...
FAILED http_tests/channel_http_test.py::test_channel_leave_v1_last_owner - si...
FAILED http_tests/channel_http_test.py::test_channel_leave_invalid_token - As...
FAILED http_tests/channels_http_test.py::test_empty_list - simplejson.errors....
FAILED http_tests/channels_http_test.py::test_list - simplejson.errors.JSONDe...
FAILED http_tests/channels_http_test.py::test_multiple_lists - simplejson.err...
FAILED http_tests/channels_http_test.py::test_list_private_channel - simplejs...
FAILED http_tests/channels_http_test.py::test_channel_list_valid_token - Asse...
FAILED http_tests/channels_http_test.py::test_empty_listall - simplejson.erro...
FAILED http_tests/channels_http_test.py::test_listall - simplejson.errors.JSO...
FAILED http_tests/channels_http_test.py::test_multiple_listall - simplejson.e...
FAILED http_tests/channels_http_test.py::test_listall_private_channel - simpl...
FAILED http_tests/channels_http_test.py::test_listall_valid_token - Assertion...
FAILED http_tests/channels_http_test.py::test_create - simplejson.errors.JSON...
FAILED http_tests/channels_http_test.py::test_channels_create_invalid_token
FAILED http_tests/dm_http_test.py::test_dm_details_v1_input_error - Assertion...
FAILED http_tests/dm_http_test.py::test_dm_details_v1_access_error - Assertio...
FAILED http_tests/dm_http_test.py::test_dm_details_v1_simple - simplejson.err...
FAILED http_tests/dm_http_test.py::test_dm_list_v1_simple - simplejson.errors...
FAILED http_tests/dm_http_test.py::test_dm_create_v1_simple - assert 237 == 0
FAILED http_tests/dm_http_test.py::test_dm_remove_v1 - AssertionError: assert...
FAILED http_tests/dm_http_test.py::test_dm_invite_v1_Invite1 - simplejson.err...
FAILED http_tests/dm_http_test.py::test_dm_invite_v1_Invite2 - simplejson.err...
FAILED http_tests/dm_http_test.py::test_dm_leave_v1_Leave1 - simplejson.error...
FAILED http_tests/dm_http_test.py::test_dm_leave_v1_LeaveALL - AssertionError...
FAILED http_tests/dm_http_test.py::test_dm_messages_v1_InputError1 - Assertio...
FAILED http_tests/dm_http_test.py::test_dm_messages_v1_InputError2 - Assertio...
FAILED http_tests/dm_http_test.py::test_dm_messages_v1_AccessError - Assertio...
FAILED http_tests/dm_http_test.py::test_dm_messages_v1_simple - simplejson.er...
FAILED http_tests/dm_http_test.py::test_dm_messages_v1_many_messages - simple...
FAILED http_tests/echo_http_test.py::test_echo - json.decoder.JSONDecodeError...
FAILED http_tests/message_http_test.py::test_message_send - simplejson.errors...
FAILED http_tests/message_http_test.py::test_message_send_input_error2 - Asse...
FAILED http_tests/message_http_test.py::test_message_send_invalid_token - Ass...
FAILED http_tests/message_http_test.py::test_message_edit - simplejson.errors...
FAILED http_tests/message_http_test.py::test_edit_message_no_error - simplejs...
FAILED http_tests/message_http_test.py::test_message_remove - simplejson.erro...
FAILED http_tests/message_http_test.py::test_message_remove_dm - simplejson.e...
FAILED http_tests/message_http_test.py::test_message_share - simplejson.error...
FAILED http_tests/message_http_test.py::test_message_share_invalid_token - As...
FAILED http_tests/message_http_test.py::test_message_senddm - simplejson.erro...
FAILED http_tests/message_http_test.py::test_message_senddm_invalid_token - A...
FAILED http_tests/other_http_test.py::test_search_v2 - AssertionError: assert...
FAILED http_tests/other_http_test.py::test_search_v2_input_error - AssertionE...
FAILED http_tests/other_http_test.py::test_notifications_get_tag - simplejson...
FAILED http_tests/other_http_test.py::test_notifications_get_add_to_channel
FAILED http_tests/other_http_test.py::test_notifications_get_tag_dm - simplej...
FAILED http_tests/other_http_test.py::test_notifications_get_add_to_dm - simp...
FAILED http_tests/user_http_test.py::test_invalid_uid - AssertionError: asser...
FAILED http_tests/user_http_test.py::test_invalid_token_profile - AssertionEr...
FAILED http_tests/user_http_test.py::test_all_users - AssertionError: assert ...
======================== 76 failed, 69 passed in 6.49s =========================
